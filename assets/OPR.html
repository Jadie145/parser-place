<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo-Parser | Operator Precedence</title>
    <link rel="icon" type="image/png" href="../logos/OPR.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Neo-Brutalism Custom Styles */
        :root {
            --neo-black: #000000;
            --neo-white: #ffffff;
            --neo-yellow: #FFDE59;
            --neo-blue: #5CE1E6;
            --neo-pink: #FF66C4;
            --neo-purple: #CBA6F7;
            --shadow-offset: 6px;
            --border-width: 3px;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f0f0f0;
            color: var(--neo-black);
        }

        .neo-card {
            background-color: var(--neo-white);
            border: var(--border-width) solid var(--neo-black);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px var(--neo-black);
            transition: all 0.2s ease;
        }

        .neo-input {
            width: 100%;
            padding: 12px;
            border: var(--border-width) solid var(--neo-black);
            background-color: var(--neo-white);
            font-weight: bold;
            font-family: inherit;
            outline: none;
            transition: all 0.2s;
        }

        .neo-input:focus {
            background-color: #fffbe6;
            box-shadow: 4px 4px 0px var(--neo-black);
        }

        .neo-btn {
            cursor: pointer;
            border: var(--border-width) solid var(--neo-black);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px var(--neo-black);
            font-weight: 900;
            text-transform: uppercase;
            padding: 12px 24px;
            transition: all 0.1s;
        }

        .neo-btn:active {
            transform: translate(var(--shadow-offset), var(--shadow-offset));
            box-shadow: 0px 0px 0px var(--neo-black);
        }

        .neo-btn-primary { background-color: var(--neo-blue); }
        .neo-btn-secondary { background-color: var(--neo-pink); }
        .neo-btn-action { background-color: var(--neo-yellow); }

        /* Back Button */
        .neo-back-btn {
            display: inline-block;
            text-decoration: none;
            color: var(--neo-black);
            background-color: var(--neo-white);
            border: var(--border-width) solid var(--neo-black);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px var(--neo-black);
            font-weight: 900;
            text-transform: uppercase;
            padding: 10px 20px;
            transition: all 0.1s;
            margin-bottom: 20px;
        }

        .neo-back-btn:hover {
            background-color: var(--neo-yellow);
        }

        .neo-back-btn:active {
            transform: translate(var(--shadow-offset), var(--shadow-offset));
            box-shadow: 0px 0px 0px var(--neo-black);
        }

        /* Table Styling */
        .neo-table-container {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            border: var(--border-width) solid var(--neo-black);
            min-width: 300px;
        }

        th, td {
            border: 2px solid var(--neo-black);
            padding: 10px;
            text-align: center;
            white-space: nowrap;
        }

        th {
            background-color: var(--neo-black);
            color: var(--neo-white);
        }

        tr:nth-child(even) { background-color: #f9f9f9; }
        tr:hover { background-color: #e0e0e0; }

        /* Scrollbar for Matrix */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track { background: #fff; border: 2px solid black; }
        ::-webkit-scrollbar-thumb { background: var(--neo-black); }

        .matrix-cell {
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .bg-pattern {
            background-image: radial-gradient(var(--neo-black) 1px, transparent 1px);
            background-size: 20px 20px;
        }
    </style>
</head>
<body class="bg-pattern min-h-screen p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        
        <a href="../index.html" class="neo-back-btn">‚Üê Back</a>
        
        <!-- Header -->
        <header class="neo-card p-6 mb-8 bg-white flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
                <h1 class="text-3xl md:text-4xl font-black tracking-tighter">OP. PRECEDENCE PARSER</h1>
                <p class="font-bold text-gray-600 mt-1">COMPILER DESIGN TOOLKIT</p>
            </div>
            <button onclick="resetApp()" class="neo-btn neo-btn-secondary w-full md:w-auto">
                Reset System
            </button>
        </header>

        <!-- Main Input Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
            
            <!-- Grammar Configuration -->
            <div class="neo-card p-6 lg:col-span-1 bg-[#CBA6F7]">
                <h2 class="text-xl font-black mb-4 bg-black text-white inline-block px-2 py-1">1. CONFIGURATION</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block font-bold mb-1">Productions (Use / for OR)</label>
                        <textarea id="productions" rows="6" class="neo-input" placeholder="B->SbS/S&#10;S->WbS/W&#10;W->L*W/L&#10;L->a">B->SbS/S
S->WbS/W
W->L*W/L
L->a</textarea>
                    </div>

                    <div>
                        <label class="block font-bold mb-1">Terminals (e.g. b*a)</label>
                        <input type="text" id="terminals" class="neo-input" value="b*a" placeholder="e.g. b*a">
                    </div>

                    <div>
                        <label class="block font-bold mb-1">Non-Terminals (e.g. BSWL)</label>
                        <input type="text" id="nonTerminals" class="neo-input" value="BSWL" placeholder="e.g. BSWL">
                    </div>

                    <button onclick="processGrammar()" class="neo-btn neo-btn-primary w-full mt-4">
                        Generate Table
                    </button>
                </div>
            </div>

            <!-- Results: Sets and Matrix -->
            <div class="neo-card p-6 lg:col-span-2 flex flex-col gap-6">
                <h2 class="text-xl font-black mb-0 bg-black text-white inline-block px-2 py-1 self-start">2. ANALYSIS RESULTS</h2>

                <!-- Sets Display -->
                <div id="setsDisplay" class="grid grid-cols-1 md:grid-cols-2 gap-4 hidden">
                    <div class="border-2 border-black p-4 bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
                        <h3 class="font-bold underline mb-2 text-lg">LEADING SETS</h3>
                        <div id="leadingOutput" class="font-mono text-sm whitespace-pre-wrap"></div>
                    </div>
                    <div class="border-2 border-black p-4 bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
                        <h3 class="font-bold underline mb-2 text-lg">TRAILING SETS</h3>
                        <div id="trailingOutput" class="font-mono text-sm whitespace-pre-wrap"></div>
                    </div>
                </div>

                <!-- Matrix Display -->
                <div id="matrixContainer" class="hidden">
                    <h3 class="font-bold mb-2">PRECEDENCE MATRIX</h3>
                    <div class="neo-table-container">
                        <table id="matrixTable">
                            <!-- Matrix JS injected here -->
                        </table>
                    </div>
                </div>

                <div id="placeholder" class="flex-1 flex items-center justify-center opacity-50 font-bold text-center py-10">
                    WAITING FOR GRAMMAR GENERATION...
                </div>
            </div>
        </div>

        <!-- Simulation Section -->
        <div id="simulationSection" class="hidden">
            <div class="neo-card p-6 bg-[#FFDE59]">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
                    <h2 class="text-xl font-black bg-black text-white inline-block px-2 py-1">3. PARSER SIMULATION</h2>
                </div>

                <div class="flex flex-col md:flex-row gap-4 mb-6">
                    <input type="text" id="testString" class="neo-input flex-1" placeholder="Enter string to test (e.g., a*b*a)">
                    <button onclick="parseString()" class="neo-btn neo-btn-primary md:w-48">
                        PARSE STRING
                    </button>
                </div>

                <!-- Parsing Table -->
                <div class="neo-table-container bg-white border-2 border-black p-1">
                    <table id="parseTable">
                        <thead>
                            <tr>
                                <th width="30%">STACK</th>
                                <th width="30%">INPUT</th>
                                <th width="40%">ACTION</th>
                            </tr>
                        </thead>
                        <tbody id="parseBody">
                            <!-- Rows injected here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- Global State ---
        let terminals = [];
        let nonTerminals = [];
        let productions = [];
        let leading = {};
        let trailing = {};
        let matrix = {};
        
        function resetApp() {
            location.reload();
        }

        // --- 1. Parsing Logic & Setup ---

        function processGrammar() {
            // 1. Get Inputs
            const prodText = document.getElementById('productions').value.trim();
            const termText = document.getElementById('terminals').value.trim();
            const nonTermText = document.getElementById('nonTerminals').value.trim();

            if(!prodText || !termText || !nonTermText) {
                alert("Please fill in all fields!");
                return;
            }

            // 2. Parse Lists
            terminals = termText.split('').filter(c => c !== ' ' && c !== ',');
            if(!terminals.includes('$')) terminals.push('$');
            
            nonTerminals = nonTermText.split('').filter(c => c !== ' ' && c !== ',');

            // 3. Parse Productions (Handle / logic)
            productions = [];
            prodText.split('\n').forEach(line => {
                line = line.trim();
                if(!line) return;
                let [lhs, rhs] = line.split('->');
                if(!lhs || !rhs) return;
                
                // Split OR alternatives
                let parts = rhs.split('/');
                parts.forEach(part => {
                    productions.push({ lhs: lhs.trim(), rhs: part.trim() });
                });
            });

            // 4. Initialize Data Structures
            leading = {};
            trailing = {};
            matrix = {};
            
            nonTerminals.forEach(nt => {
                leading[nt] = new Set();
                trailing[nt] = new Set();
            });

            terminals.forEach(t => {
                matrix[t] = {};
                terminals.forEach(t2 => {
                    matrix[t][t2] = 'e'; // e for error/empty
                });
            });

            // 5. Run Calculations
            calculateLeading();
            calculateTrailing();
            buildMatrix();

            // 6. Update UI
            displaySets();
            displayMatrix();
            
            document.getElementById('setsDisplay').classList.remove('hidden');
            document.getElementById('setsDisplay').classList.add('grid');
            document.getElementById('matrixContainer').classList.remove('hidden');
            document.getElementById('simulationSection').classList.remove('hidden');
            document.getElementById('placeholder').classList.add('hidden');
        }

        function isTerminal(char) { return terminals.includes(char); }
        function isNonTerminal(char) { return nonTerminals.includes(char); }

        // --- 2. Leading & Trailing Sets ---

        function calculateLeading() {
            let changed = true;
            while(changed) {
                changed = false;
                productions.forEach(prod => {
                    const A = prod.lhs;
                    const rhs = prod.rhs;
                    
                    // Rule 1: A -> a... implies a in Leading(A)
                    if(rhs.length > 0 && isTerminal(rhs[0])) {
                        if(!leading[A].has(rhs[0])) {
                            leading[A].add(rhs[0]);
                            changed = true;
                        }
                    }
                    
                    // Rule 2: A -> B... implies Leading(B) in Leading(A)
                    if(rhs.length > 0 && isNonTerminal(rhs[0])) {
                        const B = rhs[0];
                        leading[B].forEach(term => {
                            if(!leading[A].has(term)) {
                                leading[A].add(term);
                                changed = true;
                            }
                        });

                        // Rule 3: A -> Ba... implies a in Leading(A)
                        if(rhs.length > 1 && isTerminal(rhs[1])) {
                            if(!leading[A].has(rhs[1])) {
                                leading[A].add(rhs[1]);
                                changed = true;
                            }
                        }
                    }
                });
            }
        }

        function calculateTrailing() {
            let changed = true;
            while(changed) {
                changed = false;
                productions.forEach(prod => {
                    const A = prod.lhs;
                    const rhs = prod.rhs;
                    const len = rhs.length;

                    // Rule 1: A -> ...a implies a in Trailing(A)
                    if(len > 0 && isTerminal(rhs[len-1])) {
                        if(!trailing[A].has(rhs[len-1])) {
                            trailing[A].add(rhs[len-1]);
                            changed = true;
                        }
                    }

                    // Rule 2: A -> ...B implies Trailing(B) in Trailing(A)
                    if(len > 0 && isNonTerminal(rhs[len-1])) {
                        const B = rhs[len-1];
                        trailing[B].forEach(term => {
                            if(!trailing[A].has(term)) {
                                trailing[A].add(term);
                                changed = true;
                            }
                        });

                        // Rule 3: A -> ...aB implies a in Trailing(A)
                        if(len > 1 && isTerminal(rhs[len-2])) {
                            if(!trailing[A].has(rhs[len-2])) {
                                trailing[A].add(rhs[len-2]);
                                changed = true;
                            }
                        }
                    }
                });
            }
        }

        // --- 3. Matrix Construction ---

        function buildMatrix() {
            productions.forEach(prod => {
                const rhs = prod.rhs;
                for(let i=0; i<rhs.length-1; i++) {
                    let x = rhs[i];
                    let y = rhs[i+1];

                    // Case: ... a b ... -> a = b
                    if(isTerminal(x) && isTerminal(y)) {
                        matrix[x][y] = '=';
                    }

                    // Case: ... a B ... -> a < Leading(B)
                    if(isTerminal(x) && isNonTerminal(y)) {
                        leading[y].forEach(term => {
                            matrix[x][term] = '<';
                        });
                    }

                    // Case: ... B b ... -> Trailing(B) > b
                    if(isNonTerminal(x) && isTerminal(y)) {
                        trailing[x].forEach(term => {
                            matrix[term][y] = '>';
                        });
                    }

                    // Case: ... a B b ... -> a = b
                    if(i+2 < rhs.length) {
                        let z = rhs[i+2];
                        if(isTerminal(x) && isNonTerminal(y) && isTerminal(z)) {
                            matrix[x][z] = '=';
                        }
                    }
                }
            });

            // Handle Start Symbol ($)
            // Assuming first non-terminal entered is Start Symbol
            const startSymbol = nonTerminals[0];
            
            // $ < Leading(Start)
            leading[startSymbol].forEach(term => {
                matrix['$'][term] = '<';
            });

            // Trailing(Start) > $
            trailing[startSymbol].forEach(term => {
                matrix[term]['$'] = '>';
            });
        }

        // --- 4. Display Logic ---

        function displaySets() {
            let lHtml = "";
            let tHtml = "";
            
            nonTerminals.forEach(nt => {
                lHtml += `${nt}: { ${Array.from(leading[nt]).join(', ')} }\n`;
                tHtml += `${nt}: { ${Array.from(trailing[nt]).join(', ')} }\n`;
            });

            document.getElementById('leadingOutput').innerText = lHtml;
            document.getElementById('trailingOutput').innerText = tHtml;
        }

        function displayMatrix() {
            const table = document.getElementById('matrixTable');
            table.innerHTML = '';

            // Header Row
            let headerTr = document.createElement('tr');
            headerTr.innerHTML = '<th></th>' + terminals.map(t => `<th>${t}</th>`).join('');
            table.appendChild(headerTr);

            // Data Rows
            terminals.forEach(rowT => {
                let tr = document.createElement('tr');
                let headerCell = document.createElement('th');
                headerCell.innerText = rowT;
                tr.appendChild(headerCell);

                terminals.forEach(colT => {
                    let td = document.createElement('td');
                    let val = matrix[rowT][colT];
                    td.innerText = val === 'e' ? '' : val;
                    td.className = "matrix-cell";
                    
                    if(val === '<') td.style.color = 'green';
                    if(val === '>') td.style.color = 'red';
                    if(val === '=') td.style.color = 'blue';
                    
                    tr.appendChild(td);
                });
                table.appendChild(tr);
            });
        }

        // --- 5. Simulation/Parsing Logic ---

        function parseString() {
            let rawInput = document.getElementById('testString').value.trim();
            if(!rawInput) { alert("Enter a string!"); return; }

            // Ensure input ends with $
            if(!rawInput.endsWith('$')) rawInput += '$';

            const parseBody = document.getElementById('parseBody');
            parseBody.innerHTML = '';

            let stack = ['$'];
            let input = rawInput;
            let ptr = 0; // Input pointer
            let step = 0;

            while(true) {
                if(step > 100) { // Safety break
                    addLog(stack.join(''), input.substring(ptr), "ERROR: Limit Reached");
                    break;
                }
                step++;

                // Display current state
                const currentStack = stack.join('');
                const currentInput = input.substring(ptr);
                
                // Success Condition
                if(currentStack === '$' && currentInput === '$') {
                    addLog(currentStack, currentInput, "ACCEPTED", "bg-green-200");
                    break;
                }

                // Find topmost terminal in stack
                let topTermIndex = stack.length - 1;
                while(topTermIndex >= 0 && !isTerminal(stack[topTermIndex])) {
                    topTermIndex--;
                }
                
                let topTerm = stack[topTermIndex];
                let currentSym = input[ptr];

                // Check validity
                if(!isTerminal(currentSym)) {
                     addLog(currentStack, currentInput, "ERROR: Invalid Input Symbol", "bg-red-200");
                     break;
                }

                let relation = matrix[topTerm][currentSym];

                if(relation === '<' || relation === '=') {
                    addLog(currentStack, currentInput, `SHIFT (${relation})`);
                    stack.push(currentSym);
                    ptr++;
                }
                else if(relation === '>') {
                    addLog(currentStack, currentInput, `REDUCE (${relation})`);
                    // Pop until we find < relationship with the terminal below it
                    // In simple operator precedence simulation without constructing the tree,
                    // we basically pop the "handle".
                    
                    // Simplification: Pop until the previous terminal has a < relation
                    do {
                        stack.pop();
                        // Find new top terminal
                        topTermIndex = stack.length - 1;
                        while(topTermIndex >= 0 && !isTerminal(stack[topTermIndex])) topTermIndex--;
                        topTerm = stack[topTermIndex];
                    } while (matrix[topTerm][stack[stack.length-1]] !== '<' && topTermIndex > 0 && stack.length > 1); 
                    
                    // NOTE: This is a visual simulation. 
                    // True reduction replaces Handle with Non-Terminal.
                    // Since we don't know WHICH non-terminal produced the handle without checking RHS,
                    // simple operator precedence often just collapses the handle.
                    // To make it look nice, we push a dummy 'NT' or just leave it popped to expose previous terminal.
                    // For this demo, we just pop.
                }
                else {
                    addLog(currentStack, currentInput, "ERROR: No Relation", "bg-red-200");
                    break;
                }
            }
        }

        function addLog(stack, input, action, bgClass = "") {
            const parseBody = document.getElementById('parseBody');
            let tr = document.createElement('tr');
            if(bgClass) tr.className = bgClass;
            
            tr.innerHTML = `
                <td class="font-mono text-left pl-4">${stack}</td>
                <td class="font-mono text-right pr-4">${input}</td>
                <td class="font-bold">${action}</td>
            `;
            parseBody.appendChild(tr);
            // Auto scroll to bottom of table
            // parseBody.lastElementChild.scrollIntoView();
        }
    </script>
</body>
</html>