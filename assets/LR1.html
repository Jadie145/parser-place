<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LR(1) Parser - Memphis Edition</title>
    <link rel="icon" type="image/png" href="../logos/LR1.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
    <style>
        :root {
            --c-bg: #fdf6e3;
            --c-primary: #ff90e8; /* Pink */
            --c-secondary: #51e2f5; /* Cyan */
            --c-accent: #ffbd03; /* Yellow */
            --c-dark: #232323;
            --c-light: #ffffff;
            --font-main: 'Courier New', Courier, monospace;
            --font-head: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            --shadow-hard: 6px 6px 0px var(--c-dark);
            --shadow-hover: 2px 2px 0px var(--c-dark);
        }

        * { box-sizing: border-box; }

        body {
            font-family: var(--font-main);
            background-color: var(--c-bg);
            background-image: radial-gradient(var(--c-dark) 1px, transparent 1px);
            background-size: 24px 24px;
            color: var(--c-dark);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
        }

        /* --- Back Button --- */
        .back-btn {
            display: inline-block;
            background: var(--c-light);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 12px 24px;
            text-decoration: none;
            color: var(--c-dark);
            font-weight: bold;
            font-family: var(--font-head);
            text-transform: uppercase;
            margin-bottom: 20px;
            transition: all 0.15s;
        }

        .back-btn:hover {
            background: var(--c-secondary);
            box-shadow: var(--shadow-hover);
            transform: translate(4px, 4px);
        }

        /* --- Header --- */
        header {
            background: var(--c-accent);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 30px;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            width: 100%;
            height: 100%;
            border: 4px solid var(--c-dark);
            z-index: -1;
            background: var(--c-primary);
        }

        h1 {
            font-family: var(--font-head);
            margin: 0;
            text-transform: uppercase;
            font-weight: 900;
            font-size: 2.8rem;
            letter-spacing: -2px;
            color: var(--c-dark);
            text-shadow: 3px 3px 0px #fff;
        }

        h2, h3 {
            font-family: var(--font-head);
            text-transform: uppercase;
            margin-top: 0;
        }

        /* --- Cards --- */
        .card {
            background: var(--c-light);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 30px;
            margin-bottom: 40px;
            position: relative;
            transition: transform 0.2s;
        }

        .card-badge {
            background: var(--c-dark);
            color: var(--c-light);
            padding: 8px 20px;
            font-weight: bold;
            position: absolute;
            top: -20px;
            left: 20px;
            transform: rotate(-2deg);
            border: 2px solid var(--c-light);
            font-family: var(--font-head);
        }

        /* --- Form Elements --- */
        .input-group { margin-bottom: 20px; }

        label {
            display: block;
            font-weight: 800;
            margin-bottom: 8px;
            font-family: var(--font-head);
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        textarea, input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 3px solid var(--c-dark);
            background: #f8f8f8;
            font-family: var(--font-main);
            font-size: 1rem;
            outline: none;
            transition: 0.2s;
        }

        textarea:focus, input[type="text"]:focus {
            background: #fff;
            border-color: var(--c-primary);
            box-shadow: 4px 4px 0px var(--c-primary);
        }

        button {
            background: var(--c-secondary);
            color: var(--c-dark);
            border: 3px solid var(--c-dark);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 900;
            font-family: var(--font-head);
            cursor: pointer;
            box-shadow: var(--shadow-hard);
            text-transform: uppercase;
            display: block;
            width: 100%;
            transition: all 0.1s;
        }

        button:hover {
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0px var(--c-dark);
            background: #8df0fa;
        }

        button:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px var(--c-dark);
        }

        /* --- Output Areas --- */
        .result-section { display: none; animation: fadeIn 0.5s; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .output-block {
            background: #f0f0f0;
            border: 2px solid var(--c-dark);
            padding: 15px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        /* --- Tables --- */
        .table-wrapper {
            overflow-x: auto;
            border: 3px solid var(--c-dark);
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            min-width: 600px;
        }

        th, td {
            border: 1px solid var(--c-dark);
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
        }

        th {
            background: var(--c-primary);
            color: var(--c-dark);
            font-weight: 900;
        }

        tr:nth-child(even) { background: #fcf0e4; }
        
        .conflict { background: #ff6b6b !important; color: white; font-weight: bold; }

        /* --- State Grid --- */
        .states-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
        }

        .state-box {
            background: #fff;
            border: 3px solid var(--c-dark);
            padding: 0;
            box-shadow: 4px 4px 0px #ddd;
        }

        .state-header {
            background: var(--c-dark);
            color: var(--c-secondary);
            padding: 8px;
            font-weight: bold;
            border-bottom: 3px solid var(--c-dark);
        }

        .state-body { padding: 10px; font-size: 0.85rem; }
        .state-item { margin-bottom: 4px; border-bottom: 1px dashed #ccc; padding-bottom: 2px; }

        /* --- Graph --- */
        #graphDiv {
            background: white;
            padding: 10px;
            text-align: center;
            overflow-x: auto;
        }

        /* --- Footer/Responsive --- */
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .card { padding: 15px; }
            button { font-size: 1rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    
    <header>
        <h1>LR(1) Parser Generator</h1>
        <div style="margin-top: 10px; font-weight: bold;">Canonical Collection & Lookahead Propagation</div>
    </header>

    <!-- Input Section -->
    <div class="card">
        <div class="card-badge">INPUT CONFIG</div>
        
        <div class="input-group">
            <label>Grammar Productions</label>
            <textarea id="inputGrammar" rows="5" placeholder="E->i/(E)">S->CC
C->cC|d</textarea>
            <small style="display:block; margin-top:5px; color:#666;">
                Format: LHS->RHS (use '|' or '/' for OR, 'e' for epsilon).
            </small>
        </div>

        <div class="input-group">
            <label>Terminals (Space Separated)</label>
            <input type="text" id="inputTerminals" value="c d" placeholder="i ( )">
        </div>

        <div class="input-group">
            <label>Non-Terminals (Space Separated)</label>
            <input type="text" id="inputNonTerminals" value="S C" placeholder="E">
        </div>

        <button onclick="runParser()">GENERATE PARSER</button>
    </div>

    <!-- Results Section -->
    <div id="resultsArea" class="result-section">
        
        <!-- Grammar Info -->
        <div class="card" style="border-color: var(--c-primary);">
            <div class="card-badge" style="background: var(--c-primary); color:black;">1. ANALYSIS</div>
            <h3>Augmented Grammar</h3>
            <div id="augGrammarOutput" class="output-block"></div>
            <br>
            <h3>First Sets (Used for Lookaheads)</h3>
            <div id="firstSetsOutput" class="output-block"></div>
        </div>

        <!-- Canonical Collection -->
        <div class="card">
            <div class="card-badge">2. LR(1) STATES</div>
            <p>Items format: <code>A -> &alpha; . &beta; , [lookahead]</code></p>
            <div id="statesOutput" class="states-grid"></div>
        </div>

        <!-- Graph -->
        <div class="card" style="border-color: var(--c-secondary);">
            <div class="card-badge" style="background: var(--c-secondary); color:black;">3. GOTO GRAPH</div>
            <div id="graphDiv">Graph will appear here...</div>
        </div>

        <!-- Table -->
        <div class="card">
            <div class="card-badge">4. PARSING TABLE</div>
            <div class="table-wrapper">
                <table id="parsingTable"></table>
            </div>
            <p><small>* Red cells indicate conflicts (Not LR(1))</small></p>
        </div>

        <!-- Simulator -->
        <div class="card" style="background: #fff4f4; border-color: var(--c-accent);">
            <div class="card-badge" style="background: var(--c-accent); color:black;">5. SIMULATOR</div>
            <div class="input-group">
                <label>Test String (without $)</label>
                <input type="text" id="testString" placeholder="cdd" value="cdd">
            </div>
            <button onclick="parseString()" style="background: var(--c-primary);">PARSE STRING</button>
            
            <div id="parseResultMsg" style="margin: 15px 0; font-weight: bold; font-size: 1.2rem; text-align: center;"></div>

            <div class="table-wrapper">
                <table id="traceTable">
                    <thead>
                        <tr>
                            <th style="width: 40%">Stack</th>
                            <th style="width: 30%">Input</th>
                            <th style="width: 30%">Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    // Initialize Mermaid
    mermaid.initialize({ startOnLoad: false, theme: 'neutral', securityLevel: 'loose' });

    // --- Data Structures ---
    class Production {
        constructor(id, lhs, rhs) {
            this.id = id;
            this.lhs = lhs;
            this.rhs = rhs; // String (e.g., "E+T") or "e" for epsilon
        }
    }

    class Item {
        constructor(prodIndex, dotPos, lookahead) {
            this.prodIndex = prodIndex;
            this.dotPos = dotPos;
            this.lookahead = lookahead; // Single char (terminal or $)
        }
        
        getKey() {
            return `${this.prodIndex}:${this.dotPos}:${this.lookahead}`;
        }
    }

    // --- Global State ---
    let grammar = [];
    let terminals = [];
    let nonTerminals = [];
    let firstSets = {};
    let states = []; // Array of Item[]
    let gotoGraph = []; // Array of {from, to, symbol}
    let actionTable = {}; // [state][symbol] = "S1", "r2", "acc"
    let gotoTable = {};   // [state][symbol] = stateIndex

    // --- Main Execution ---
    function runParser() {
        // 1. Reset
        grammar = [];
        states = [];
        gotoGraph = [];
        actionTable = {};
        gotoTable = {};
        firstSets = {};
        
        // 2. Parse Input
        const gText = document.getElementById('inputGrammar').value.trim();
        const tText = document.getElementById('inputTerminals').value.trim();
        const ntText = document.getElementById('inputNonTerminals').value.trim();

        if(!gText || !tText || !ntText) { alert("Please fill all fields"); return; }

        terminals = tText.split(/\s+/);
        if(!terminals.includes('$')) terminals.push('$');
        
        nonTerminals = ntText.split(/\s+/);
        // Add Augmented Start 'Z'
        if(!nonTerminals.includes('Z')) nonTerminals.unshift('Z'); 

        // Parse Grammar
        let rawLines = gText.split('\n');
        let prodCount = 0;
        
        // Augmented Rule 0: Z -> S (assuming S is first NT user entered)
        let userStart = nonTerminals[1]; // 0 is Z, 1 is User Start
        grammar.push(new Production(0, 'Z', userStart));
        prodCount++;

        rawLines.forEach(line => {
            if(!line.trim()) return;
            let parts = line.split(/->|=/);
            if(parts.length < 2) return;
            let lhs = parts[0].trim();
            let rhsList = parts[1].split(/\/|\|/);
            
            rhsList.forEach(rhs => {
                grammar.push(new Production(prodCount++, lhs, rhs.trim()));
            });
        });

        // Display Grammar
        let augHtml = grammar.map(p => `${p.id}: ${p.lhs} -> ${p.rhs}`).join('\n');
        document.getElementById('augGrammarOutput').innerText = augHtml;

        // 3. Compute FIRST sets
        computeFirstSets();
        let firstHtml = Object.keys(firstSets).map(k => `FIRST(${k}) = { ${Array.from(firstSets[k]).join(', ')} }`).join('\n');
        document.getElementById('firstSetsOutput').innerText = firstHtml;

        // 4. Generate States (Canonical Collection)
        generateCanonicalCollection();
        renderStates();

        // 5. Build Tables
        buildTables();
        renderTable();

        // 6. Render Graph
        renderGraph();

        // Show results
        document.getElementById('resultsArea').style.display = 'block';
    }

    // --- Algorithms ---

    function isTerminal(sym) { return terminals.includes(sym); }
    function isNonTerminal(sym) { return nonTerminals.includes(sym); }

    function computeFirstSets() {
        // Initialize
        nonTerminals.forEach(nt => firstSets[nt] = new Set());
        terminals.forEach(t => {
            firstSets[t] = new Set([t]);
        });
        
        let changed = true;
        while(changed) {
            changed = false;
            grammar.forEach(prod => {
                let lhs = prod.lhs;
                let rhs = prod.rhs;
                
                let initialSize = firstSets[lhs].size;

                if(rhs === 'e') {
                    firstSets[lhs].add('e');
                } else {
                    // Calculate FIRST of RHS string
                    let rhsFirst = getFirstOfString(rhs);
                    rhsFirst.forEach(x => firstSets[lhs].add(x));
                }

                if(firstSets[lhs].size > initialSize) changed = true;
            });
        }
    }

    // Helper: Get FIRST of a string sequence (e.g. "Ab")
    function getFirstOfString(str) {
        let result = new Set();
        let allNullable = true;
        
        // Treat string as array of characters/tokens
        // Simplified: Assuming single char tokens unless strict matching
        // For the parser we will iterate char by char if tokens are single chars, 
        // but here we rely on our terminal/NT definitions.
        // Let's assume symbols are 1 char long for the logic string parsing
        // to match the user's request example.
        
        for(let i=0; i<str.length; i++) {
            let sym = str[i];
            let symFirst = firstSets[sym];
            
            if(!symFirst) { 
                // Fallback for literals not declared? assume terminal
                result.add(sym); 
                allNullable = false; 
                break; 
            }

            let hasEpsilon = false;
            symFirst.forEach(x => {
                if(x === 'e') hasEpsilon = true;
                else result.add(x);
            });

            if(!hasEpsilon) {
                allNullable = false;
                break;
            }
        }

        if(allNullable) result.add('e');
        return result;
    }

    // --- LR(1) Logic ---

    function closure(items) {
        let currentItems = [...items]; // Copy
        let added = true;

        while(added) {
            added = false;
            // Use index loop because currentItems grows
            for(let i=0; i<currentItems.length; i++) {
                let item = currentItems[i];
                let prod = grammar[item.prodIndex];
                let rhs = prod.rhs;

                // Check if dot is before a NonTerminal
                // item: A -> alpha . B beta, a
                if(item.dotPos < rhs.length && rhs !== 'e') {
                    let B = rhs[item.dotPos];
                    
                    if(isNonTerminal(B)) {
                        // Found B. Need to compute lookahead for B.
                        // Lookahead is FIRST(beta a)
                        
                        let beta = rhs.substring(item.dotPos + 1);
                        let firstOfBetaA = getFirstOfString(beta + item.lookahead);
                        
                        // Add productions for B
                        grammar.forEach((p, pIdx) => {
                            if(p.lhs === B) {
                                firstOfBetaA.forEach(b => {
                                    // b cannot be epsilon for lookahead in LR(1) items usually, 
                                    // unless we are at end of stream.
                                    if(b === 'e') return; 

                                    let newItem = new Item(pIdx, 0, b);
                                    // Check if exists
                                    if(!currentItems.some(ex => ex.getKey() === newItem.getKey())) {
                                        currentItems.push(newItem);
                                        added = true;
                                    }
                                });
                            }
                        });
                    }
                } else if (rhs === 'e' && item.dotPos === 0) {
                   // Handle epsilon production A -> .e becomes A -> e. (dot moves over)
                   // Effectively dotPos 1 means end of 'e'
                   // But for code simplicity, we often treat 'e' productions as having length 1 or 0.
                   // Let's treat dotPos=1 as "reduced" for epsilon.
                }
            }
        }
        return currentItems.sort((a,b) => a.getKey().localeCompare(b.getKey()));
    }

    function goto(items, symbol) {
        let newItems = [];
        items.forEach(item => {
            let prod = grammar[item.prodIndex];
            let rhs = prod.rhs;

            if(rhs === 'e') return; // Cannot shift epsilon

            if(item.dotPos < rhs.length && rhs[item.dotPos] === symbol) {
                newItems.push(new Item(item.prodIndex, item.dotPos + 1, item.lookahead));
            }
        });
        
        if(newItems.length === 0) return null;
        return closure(newItems);
    }

    function sameState(s1, s2) {
        if(s1.length !== s2.length) return false;
        for(let i=0; i<s1.length; i++) {
            if(s1[i].getKey() !== s2[i].getKey()) return false;
        }
        return true;
    }

    function generateCanonicalCollection() {
        // I0: Closure({ Z -> .S, $ })
        let startItem = new Item(0, 0, '$');
        let I0 = closure([startItem]);
        states.push(I0);

        let processed = 0;
        while(processed < states.length) {
            let currentI = states[processed];
            
            // Collect all symbols appearing after dots
            let symbolsAfterDot = new Set();
            currentI.forEach(item => {
                let rhs = grammar[item.prodIndex].rhs;
                if(rhs !== 'e' && item.dotPos < rhs.length) {
                    symbolsAfterDot.add(rhs[item.dotPos]);
                }
            });

            symbolsAfterDot.forEach(sym => {
                let nextI = goto(currentI, sym);
                if(nextI) {
                    // Check if state exists
                    let existingIdx = -1;
                    for(let k=0; k<states.length; k++) {
                        if(sameState(states[k], nextI)) {
                            existingIdx = k;
                            break;
                        }
                    }

                    if(existingIdx === -1) {
                        existingIdx = states.length;
                        states.push(nextI);
                    }

                    // Record transition
                    gotoGraph.push({ from: processed, to: existingIdx, label: sym });
                    
                    if(isTerminal(sym)) {
                        if(!actionTable[processed]) actionTable[processed] = {};
                        // Conflict Check
                        if(actionTable[processed][sym]) {
                             actionTable[processed][sym] += `/S${existingIdx}`; // Shift/Shift conflict?
                        } else {
                             actionTable[processed][sym] = `S${existingIdx}`;
                        }
                    } else {
                        if(!gotoTable[processed]) gotoTable[processed] = {};
                        gotoTable[processed][sym] = existingIdx;
                    }
                }
            });
            processed++;
        }
    }

    function buildTables() {
        // We filled Shifts in GenerateCanonical. Now Fill Reduces.
        states.forEach((stateItems, stateIdx) => {
            stateItems.forEach(item => {
                let prod = grammar[item.prodIndex];
                let rhs = prod.rhs;
                
                // Check for Reduction Condition: Dot at end, or Epsilon
                if((rhs === 'e' && item.dotPos === 0) || item.dotPos === rhs.length) {
                    
                    if(prod.lhs === 'Z') {
                        // Accept condition: Z -> S. , $
                        if(item.lookahead === '$') {
                            if(!actionTable[stateIdx]) actionTable[stateIdx] = {};
                            actionTable[stateIdx]['$'] = 'acc';
                        }
                    } else {
                        // Regular Reduce
                        // LR(1): Place reduce ONLY in the lookahead column
                        let la = item.lookahead;
                        if(!actionTable[stateIdx]) actionTable[stateIdx] = {};
                        
                        let entry = actionTable[stateIdx][la];
                        let newEntry = `r${prod.id}`;
                        
                        if(entry) {
                            // Conflict
                            if(!entry.includes(newEntry)) { // Avoid duplicate reduces
                                actionTable[stateIdx][la] += `/${newEntry}`;
                            }
                        } else {
                            actionTable[stateIdx][la] = newEntry;
                        }
                    }
                }
            });
        });
    }

    // --- Rendering ---

    function renderStates() {
        const container = document.getElementById('statesOutput');
        container.innerHTML = "";
        
        states.forEach((items, idx) => {
            let div = document.createElement('div');
            div.className = 'state-box';
            
            let html = `<div class="state-header">State I${idx}</div><div class="state-body">`;
            
            items.forEach(it => {
                let p = grammar[it.prodIndex];
                let rhsStr = "";
                if(p.rhs === 'e') {
                    rhsStr = "."; // Display A -> .
                } else {
                    rhsStr = p.rhs.substring(0, it.dotPos) + "." + p.rhs.substring(it.dotPos);
                }
                html += `<div class="state-item">${p.lhs} &rarr; ${rhsStr}, <b>${it.lookahead}</b></div>`;
            });
            html += "</div>";
            div.innerHTML = html;
            container.appendChild(div);
        });
    }

    function renderGraph() {
        let def = "graph TD;\n";
        // Nodes
        for(let i=0; i<states.length; i++) {
            def += `S${i}(("I${i}"))\n`;
            def += `style S${i} fill:#fff,stroke:#333,stroke-width:2px\n`;
        }
        // Edges
        gotoGraph.forEach(edge => {
            def += `S${edge.from} -- ${edge.label} --> S${edge.to}\n`;
        });

        const div = document.getElementById('graphDiv');
        div.innerHTML = `<pre class="mermaid">${def}</pre>`;
        div.removeAttribute('data-processed'); // Reset mermaid
        mermaid.run({ nodes: [div.querySelector('.mermaid')] });
    }

    function renderTable() {
        const tbl = document.getElementById('parsingTable');
        tbl.innerHTML = "";
        
        // Header
        let head = "<thead><tr><th>State</th>";
        terminals.forEach(t => head += `<th>${t}</th>`);
        nonTerminals.forEach(nt => {
            if(nt !== 'Z') head += `<th>${nt}</th>`;
        });
        head += "</tr></thead>";
        tbl.innerHTML = head;

        // Body
        let body = "<tbody>";
        for(let i=0; i<states.length; i++) {
            body += `<tr><td><b>${i}</b></td>`;
            
            // Action part
            terminals.forEach(t => {
                let act = (actionTable[i] && actionTable[i][t]) ? actionTable[i][t] : "";
                let cls = act.includes('/') ? 'conflict' : '';
                body += `<td class="${cls}">${act}</td>`;
            });
            
            // Goto part
            nonTerminals.forEach(nt => {
                if(nt !== 'Z') {
                    let g = (gotoTable[i] && gotoTable[i][nt] !== undefined) ? gotoTable[i][nt] : "";
                    body += `<td>${g}</td>`;
                }
            });
            body += "</tr>";
        }
        body += "</tbody>";
        tbl.innerHTML += body;
    }

    // --- Simulation ---

    function parseString() {
        let input = document.getElementById('testString').value.trim();
        input += "$";
        
        let stack = [0];
        let symStack = ['$']; // Initialize with bottom marker
        let ptr = 0;
        
        let tbody = document.querySelector("#traceTable tbody");
        tbody.innerHTML = "";
        
        let msg = document.getElementById("parseResultMsg");
        msg.innerHTML = "";
        msg.style.color = "black";

        let maxSteps = 500;
        let steps = 0;

        while(steps < maxSteps) {
            let currentState = stack[stack.length - 1];
            let currentSym = input[ptr];
            
            // Handle unknown symbols
            if(!terminals.includes(currentSym)) {
                msg.innerText = `Error: Unknown symbol '${currentSym}'`;
                msg.style.color = "red";
                return;
            }

            let action = actionTable[currentState] ? actionTable[currentState][currentSym] : null;
            
            // Generate interleaved stack string (e.g., $0(3i2)
            let stackDisplay = "";
            for(let i=0; i<stack.length; i++) {
                stackDisplay += symStack[i] + stack[i];
            }

            // Render Row
            let row = `<tr>
                <td style="font-family: monospace; letter-spacing: -1px;">${stackDisplay}</td>
                <td>${input.substring(ptr)}</td>
                <td>${action || "Error"}</td>
            </tr>`;
            tbody.innerHTML += row;

            if(!action) {
                msg.innerText = "REJECTED: Syntax Error";
                msg.style.color = "red";
                return;
            }

            // Handle Conflict in simulator (Greedy: Shift preferred, else first reduce)
            if(action.includes('/')) {
                let parts = action.split('/');
                let shift = parts.find(p => p.startsWith('S'));
                if(shift) action = shift;
                else action = parts[0];
            }

            if(action === 'acc') {
                msg.innerText = "ACCEPTED: Valid String";
                msg.style.color = "#009900";
                return;
            }

            if(action.startsWith('S')) {
                // Shift
                let nextState = parseInt(action.substring(1));
                stack.push(nextState);
                symStack.push(currentSym);
                ptr++;
            } else if (action.startsWith('r')) {
                // Reduce
                let prodId = parseInt(action.substring(1));
                let prod = grammar.find(p => p.id === prodId);
                
                let popCount = prod.rhs === 'e' ? 0 : prod.rhs.length;
                
                for(let k=0; k<popCount; k++) {
                    stack.pop();
                    symStack.pop();
                }
                
                let top = stack[stack.length - 1];
                let nextState = gotoTable[top][prod.lhs];
                
                if(nextState === undefined) {
                    msg.innerText = "Error: Goto Fault";
                    msg.style.color = "red";
                    return;
                }
                
                stack.push(nextState);
                symStack.push(prod.lhs);
            }
            steps++;
        }
        msg.innerText = "Terminated: Step Limit Reached";
    }
</script>

</body>
</html>