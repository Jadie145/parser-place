<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LR(0) Parser - Memphis Edition</title>
    <link rel="icon" type="image/png" href="../logos/LR0.png">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        :root {
            --c-bg: #fcf0e4;
            --c-primary: #ff90e8; /* Pink */
            --c-secondary: #51e2f5; /* Cyan */
            --c-accent: #ffbd03; /* Yellow */
            --c-dark: #232323;
            --c-light: #ffffff;
            --font-main: 'Courier New', Courier, monospace;
            --shadow-hard: 5px 5px 0px var(--c-dark);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--c-bg);
            background-image: radial-gradient(var(--c-secondary) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--c-dark);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Back Button */
        .back-btn {
            display: inline-block;
            background: var(--c-light);
            border: 3px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 10px 20px;
            text-decoration: none;
            color: var(--c-dark);
            font-weight: bold;
            margin-bottom: 20px;
            transition: all 0.1s;
        }

        .back-btn:hover {
            background: var(--c-secondary);
        }

        .back-btn:active {
            transform: translate(3px, 3px);
            box-shadow: 2px 2px 0px var(--c-dark);
        }

        /* Header */
        header {
            background: var(--c-accent);
            border: 3px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 20px;
            text-align: center;
            margin-bottom: 40px;
            transform: rotate(-1deg);
        }

        h1 {
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -1px;
            font-size: 2.5rem;
        }

        /* Cards */
        .card {
            background: var(--c-light);
            border: 3px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
        }

        .card-title {
            background: var(--c-dark);
            color: var(--c-light);
            display: inline-block;
            padding: 5px 15px;
            font-weight: bold;
            position: absolute;
            top: -15px;
            left: 20px;
            transform: rotate(1deg);
        }

        /* Inputs */
        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            border: 3px solid var(--c-dark);
            background: #f4f4f4;
            font-family: var(--font-main);
            font-size: 1rem;
            outline: none;
        }

        input[type="text"]:focus, textarea:focus {
            background: #fff;
            border-color: var(--c-primary);
        }

        .btn-primary {
            background: var(--c-secondary);
            color: var(--c-dark);
            border: 3px solid var(--c-dark);
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: var(--shadow-hard);
            transition: transform 0.1s;
            display: block;
            width: 100%;
            text-transform: uppercase;
        }

        .btn-primary:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px var(--c-dark);
        }

        .btn-primary:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px var(--c-dark);
        }

        /* Output Sections */
        .result-section {
            display: none; /* Hidden by default */
        }

        .output-block {
            background: #eee;
            border: 2px solid var(--c-dark);
            padding: 15px;
            margin-bottom: 15px;
            white-space: pre-wrap;
            font-size: 0.9rem;
        }

        /* Tables */
        .table-wrapper {
            overflow-x: auto;
            margin-bottom: 20px;
            border: 2px solid var(--c-dark);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }

        th, td {
            padding: 10px;
            border: 1px solid var(--c-dark);
            text-align: center;
        }

        th {
            background: var(--c-primary);
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* States Grid */
        .states-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .state-box {
            background: var(--c-bg);
            border: 2px solid var(--c-dark);
            padding: 10px;
            font-size: 0.8rem;
        }
        
        .state-header {
            font-weight: bold;
            border-bottom: 2px solid var(--c-dark);
            margin-bottom: 5px;
            padding-bottom: 5px;
            color: var(--c-secondary);
            background: var(--c-dark);
            padding: 5px;
        }

        /* Graph */
        #graphDiv {
            text-align: center;
            padding: 10px;
            background: white;
        }

        /* Responsive */
        @media (max-width: 600px) {
            h1 { font-size: 1.8rem; }
            .card { padding: 15px; }
        }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="back-btn">← Back</a>
    
    <header>
        <h1>LR(0) Parser Generator</h1>
        <p>Memphis Design Edition</p>
    </header>

    <!-- Input Section -->
    <div class="card">
        <div class="card-title">Configuration</div>
        
        <div class="input-group">
            <label>Grammar Productions (one per line, e.g., E->i/(E))</label>
            <textarea id="inputGrammar" rows="4" placeholder="E->i/(E)">E->i/(E)</textarea>
            <small>Use 'e' for epsilon. Use '->' to separate LHS and RHS. Use '/' or '|' for multiple RHS.</small>
        </div>

        <div class="input-group">
            <label>Terminals (e.g., i ( ) )</label>
            <input type="text" id="inputTerminals" placeholder="i ( )" value="i ( )">
        </div>

        <div class="input-group">
            <label>Non-Terminals (e.g., E)</label>
            <input type="text" id="inputNonTerminals" placeholder="E" value="E">
        </div>

        <button class="btn-primary" onclick="runParser()">Generate Parser</button>
    </div>

    <!-- Results Section -->
    <div id="resultsArea" class="result-section">
        
        <!-- Grammar & Sets -->
        <div class="card">
            <div class="card-title">1. Analysis</div>
            <h3>Augmented Grammar</h3>
            <div id="augGrammarOutput" class="output-block"></div>
            
            <h3>First & Follow Sets</h3>
            <div id="firstFollowOutput" class="output-block"></div>
        </div>

        <!-- States -->
        <div class="card">
            <div class="card-title">2. Canonical Collection (States)</div>
            <div id="statesOutput" class="states-grid"></div>
        </div>

        <!-- Graph -->
        <div class="card">
            <div class="card-title">3. GoTo Graph</div>
            <div id="graphDiv"></div>
        </div>

        <!-- Parsing Table -->
        <div class="card">
            <div class="card-title">4. Parsing Table</div>
            <div class="table-wrapper">
                <table id="parsingTable"></table>
            </div>
        </div>

        <!-- Parser Test -->
        <div class="card" style="border-color: var(--c-primary);">
            <div class="card-title" style="background: var(--c-primary); color: black;">5. Test String</div>
            <div class="input-group">
                <label>Enter String to Parse:</label>
                <input type="text" id="testString" placeholder="(i)">
            </div>
            <button class="btn-primary" onclick="parseString()" style="background: var(--c-accent);">Parse String</button>
            
            <h3 style="margin-top: 20px;">Trace</h3>
            <div class="table-wrapper">
                <table id="traceTable">
                    <thead>
                        <tr>
                            <th>Stack</th>
                            <th>Input Buffer</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div id="parseResultMsg" style="font-weight: bold; text-align: center; padding: 10px; border: 2px solid black; margin-top: 10px; display:none;"></div>
        </div>

    </div>
</div>

<script>
    mermaid.initialize({ startOnLoad: false, theme: 'neutral' });

    // --- Global Logic Variables ---
    let grammar = [];
    let terminals = [];
    let nonTerminals = [];
    let canonicalCollection = []; // Array of States
    let actionTable = {}; // { stateIdx: { symbol: actionString } }
    let gotoTable = {};   // { stateIdx: { symbol: stateIdx } }
    let firstSets = {};
    let followSets = {};

    // --- Classes ---
    class Production {
        constructor(lhs, rhs) {
            this.lhs = lhs;
            this.rhs = rhs; // String
        }
    }

    class Item {
        constructor(prodIndex, dotPos) {
            this.prodIndex = prodIndex;
            this.dotPos = dotPos;
        }
    }

    // --- Main Execution Function ---
    function runParser() {
        // 1. Reset
        grammar = [];
        terminals = [];
        nonTerminals = [];
        canonicalCollection = [];
        actionTable = {};
        gotoTable = {};
        firstSets = {};
        followSets = {};
        
        // 2. Parse Input
        const gramText = document.getElementById('inputGrammar').value.trim();
        const termText = document.getElementById('inputTerminals').value.trim();
        const nonTermText = document.getElementById('inputNonTerminals').value.trim();

        if(!gramText || !termText || !nonTermText) {
            alert("Please fill in all fields.");
            return;
        }

        // Parse Terminals
        terminals = termText.split(/\s+/);
        if(!terminals.includes('$')) terminals.push('$'); // Add end marker if missing

        // Parse Non-Terminals
        nonTerminals = nonTermText.split(/\s+/);
        // FIX: Ensure Z (augmented start) is in nonTerminals to allow Set initialization
        if(!nonTerminals.includes('Z')) {
            nonTerminals.push('Z');
        }

        // Parse Grammar
        const lines = gramText.split('\n');
        let tempGrammar = [];
        let startSymbol = "";

        lines.forEach(line => {
            if(!line.trim()) return;
            let parts = line.split('->');
            if(parts.length < 2) parts = line.split('='); // Support A=...
            
            if(parts.length < 2) return; // Skip invalid lines

            const lhs = parts[0].trim();
            if(startSymbol === "") startSymbol = lhs;

            const rhsParts = parts[1].split(/\||\//); // Split by | or /
            
            rhsParts.forEach(r => {
                tempGrammar.push(new Production(lhs, r.trim()));
            });
        });

        if(startSymbol === "") {
             alert("Could not parse grammar. check syntax.");
             return;
        }

        // 3. Augmentation
        // Z -> StartSymbol
        grammar.push(new Production('Z', startSymbol));
        tempGrammar.forEach(p => grammar.push(p));

        // Display Augmented
        let augHtml = "";
        grammar.forEach((p, i) => {
            augHtml += `${i}: ${p.lhs} -> ${p.rhs}\n`;
        });
        document.getElementById('augGrammarOutput').innerText = augHtml;

        // 4. First & Follow (Logic ported from C)
        computeFirstSets();
        computeFollowSets();
        displaySets();

        // 5. Generate States (I0, I1...)
        generateStates();
        displayStates();

        // 6. Build Table
        buildTable();
        displayTable();

        // 7. Draw Graph
        drawGraph();

        // Show Results
        document.getElementById('resultsArea').style.display = 'block';
    }

    // --- Logic Helpers ---

    function isNonTerminal(char) {
        return nonTerminals.includes(char);
    }

    function isTerminal(char) {
        if(char === 'e') return false; // epsilon
        return terminals.includes(char);
    }

    function addToSet(setObj, key, val) {
        if(!setObj[key]) setObj[key] = new Set();
        setObj[key].add(val);
    }

    // --- First & Follow ---
    function computeFirstSets() {
        firstSets = {};
        nonTerminals.forEach(nt => firstSets[nt] = new Set());

        let changed = true;
        while(changed) {
            changed = false;
            for(let i=0; i<grammar.length; i++) {
                let lhs = grammar[i].lhs;
                // Ensure Z is calculated too
                
                let rhs = grammar[i].rhs;
                if(rhs.length === 0) continue; 

                let f = rhs[0];
                
                if(!firstSets[lhs]) firstSets[lhs] = new Set();
                let initialSize = firstSets[lhs].size;

                if(isTerminal(f) || f === '(' || f === ')') {
                     firstSets[lhs].add(f);
                } else if (f === 'e') {
                     firstSets[lhs].add('e');
                } else if (isNonTerminal(f)) {
                    // Add First(f) to First(lhs)
                    if(firstSets[f]) {
                        firstSets[f].forEach(x => firstSets[lhs].add(x));
                    }
                }

                if(firstSets[lhs].size > initialSize) changed = true;
            }
        }
    }

    function computeFollowSets() {
        followSets = {};
        nonTerminals.forEach(nt => followSets[nt] = new Set());
        
        // Start symbol follows $
        let origStart = grammar[0].rhs; // Z->S, so S is original start
        if(followSets[origStart]) {
            followSets[origStart].add('$'); 
        }

        let changed = true;
        while(changed) {
            changed = false;
            for(let i=0; i<grammar.length; i++) {
                let lhs = grammar[i].lhs;
                let rhs = grammar[i].rhs;
                if(rhs === 'e') continue;

                for(let j=0; j<rhs.length; j++) {
                    let B = rhs[j];
                    if(isNonTerminal(B)) {
                        if(!followSets[B]) continue;

                        let initialSize = followSets[B].size;

                        // Look ahead
                        if(j + 1 < rhs.length) {
                            let beta = rhs[j+1];
                            if(isTerminal(beta)) {
                                followSets[B].add(beta);
                            } else if(isNonTerminal(beta)) {
                                // Add First(beta) - {e}
                                if(firstSets[beta]) {
                                    firstSets[beta].forEach(x => {
                                        if(x !== 'e') followSets[B].add(x);
                                    });
                                    // If First(beta) has epsilon, add Follow(lhs)
                                    if(firstSets[beta].has('e')) {
                                        if(followSets[lhs]) {
                                            followSets[lhs].forEach(x => followSets[B].add(x));
                                        }
                                    }
                                }
                            }
                        } else {
                            // At end, add Follow(lhs)
                            if(followSets[lhs]) {
                                followSets[lhs].forEach(x => followSets[B].add(x));
                            }
                        }

                        if(followSets[B].size > initialSize) changed = true;
                    }
                }
            }
        }
    }

    function displaySets() {
        let out = "";
        nonTerminals.forEach(nt => {
            let f = Array.from(firstSets[nt] || []).join(', ');
            let fl = Array.from(followSets[nt] || []).join(', ');
            out += `First(${nt}) = { ${f} } | Follow(${nt}) = { ${fl} }\n`;
        });
        document.getElementById('firstFollowOutput').innerText = out;
    }

    // --- State Generation (Canonical Collection) ---
    
    function closure(items) {
        let newItems = [...items];
        let changed = true;
        while(changed) {
            changed = false;
            for(let i=0; i<newItems.length; i++) {
                let prodIdx = newItems[i].prodIndex;
                let dot = newItems[i].dotPos;
                let rhs = grammar[prodIdx].rhs;

                if(dot < rhs.length) {
                    let symbol = rhs[dot];
                    if(isNonTerminal(symbol)) {
                        // Add productions for this NT
                        for(let k=0; k<grammar.length; k++) {
                            if(grammar[k].lhs === symbol) {
                                // Check if already exists
                                let exists = newItems.some(it => it.prodIndex === k && it.dotPos === 0);
                                if(!exists) {
                                    newItems.push(new Item(k, 0));
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return newItems;
    }

    function computeGoto(stateIdx, symbol) {
        let currentItems = canonicalCollection[stateIdx];
        let nextItems = [];

        currentItems.forEach(it => {
            let rhs = grammar[it.prodIndex].rhs;
            if(it.dotPos < rhs.length) {
                if(rhs[it.dotPos] === symbol) {
                    nextItems.push(new Item(it.prodIndex, it.dotPos + 1));
                }
            }
        });

        if(nextItems.length === 0) return null;
        return closure(nextItems);
    }

    function itemsEqual(items1, items2) {
        if(items1.length !== items2.length) return false;
        // Sort and stringify to compare
        const sig1 = items1.map(i => `${i.prodIndex}:${i.dotPos}`).sort().join('|');
        const sig2 = items2.map(i => `${i.prodIndex}:${i.dotPos}`).sort().join('|');
        return sig1 === sig2;
    }

    function findStateIndex(items) {
        for(let i=0; i<canonicalCollection.length; i++) {
            if(itemsEqual(canonicalCollection[i], items)) return i;
        }
        return -1;
    }

    function generateStates() {
        // I0
        let initialItem = new Item(0, 0); // Z -> .S
        canonicalCollection = [closure([initialItem])];

        let processed = 0;
        // Logic to track graph edges for Mermaid
        window.graphEdges = []; 

        while(processed < canonicalCollection.length) {
            // Order: NonTerminals FIRST (as requested), then Terminals
            
            // 1. Non-Terminals
            nonTerminals.forEach(nt => {
                let nextStateItems = computeGoto(processed, nt);
                if(nextStateItems) {
                    let idx = findStateIndex(nextStateItems);
                    if(idx === -1) {
                        idx = canonicalCollection.length;
                        canonicalCollection.push(nextStateItems);
                    }
                    gotoTable[processed] = gotoTable[processed] || {};
                    gotoTable[processed][nt] = idx;
                    window.graphEdges.push({ from: processed, to: idx, label: nt });
                }
            });

            // 2. Terminals
            terminals.forEach(t => {
                if(t === '$') return;
                let nextStateItems = computeGoto(processed, t);
                if(nextStateItems) {
                    let idx = findStateIndex(nextStateItems);
                    if(idx === -1) {
                        idx = canonicalCollection.length;
                        canonicalCollection.push(nextStateItems);
                    }
                    actionTable[processed] = actionTable[processed] || {};
                    actionTable[processed][t] = `S${idx}`; // Shift
                    window.graphEdges.push({ from: processed, to: idx, label: t });
                }
            });

            processed++;
        }
    }

    function displayStates() {
        const container = document.getElementById('statesOutput');
        container.innerHTML = "";
        
        canonicalCollection.forEach((items, idx) => {
            let box = document.createElement('div');
            box.className = 'state-box';
            
            let html = `<div class="state-header">I${idx}</div>`;
            items.forEach(it => {
                let p = grammar[it.prodIndex];
                let rhs = p.rhs;
                let rhsWithDot = "";
                for(let k=0; k<rhs.length; k++) {
                    if(k === it.dotPos) rhsWithDot += ".";
                    rhsWithDot += rhs[k];
                }
                if(it.dotPos === rhs.length) rhsWithDot += ".";
                html += `<div>${p.lhs} -> ${rhsWithDot}</div>`;
            });
            box.innerHTML = html;
            container.appendChild(box);
        });
    }

    function drawGraph() {
        const div = document.getElementById('graphDiv');
        div.innerHTML = ''; // Clear previous
        
        let graphDef = "graph TD;\n";
        // Nodes
        for(let i=0; i<canonicalCollection.length; i++) {
            graphDef += `    ${i}(("I${i}"))\n`;
            // Style nodes
            graphDef += `    style ${i} fill:#fff,stroke:#333,stroke-width:2px\n`;
        }
        // Edges
        window.graphEdges.forEach(edge => {
            graphDef += `    ${edge.from} -- "${edge.label}" --> ${edge.to}\n`;
        });

        // Render
        div.innerHTML = `<pre class="mermaid">${graphDef}</pre>`;
        mermaid.run({ nodes: [div.querySelector('.mermaid')] });
    }

    // --- Parsing Table ---

    function buildTable() {
        // We already filled Shifts in generateStates. Now fill Reduces.
        
        for(let i=0; i<canonicalCollection.length; i++) {
            let items = canonicalCollection[i];
            if(!actionTable[i]) actionTable[i] = {};

            items.forEach(it => {
                let rhs = grammar[it.prodIndex].rhs;
                let isComplete = (it.dotPos === rhs.length) || (rhs === 'e');

                if(isComplete) {
                    if(grammar[it.prodIndex].lhs === 'Z') {
                        // Accept
                        actionTable[i]['$'] = 'acc';
                    } else {
                        // LR(0) Reduce: Add reduce to ALL terminals
                        terminals.forEach(t => {
                            // Conflict check? Simple override for now as per C code
                            if(!actionTable[i][t]) {
                                actionTable[i][t] = `r${it.prodIndex}`;
                            }
                        });
                    }
                }
            });
        }
    }

    function displayTable() {
        const tbl = document.getElementById('parsingTable');
        tbl.innerHTML = "";

        // Header
        let thead = "<thead><tr><th>State</th>";
        terminals.forEach(t => thead += `<th>${t}</th>`);
        nonTerminals.forEach(nt => thead += `<th>${nt}</th>`);
        thead += "</tr></thead>";
        tbl.innerHTML = thead;

        // Body
        let tbody = "<tbody>";
        for(let i=0; i<canonicalCollection.length; i++) {
            tbody += `<tr><td><b>I${i}</b></td>`;
            
            // Action Columns
            terminals.forEach(t => {
                let act = (actionTable[i] && actionTable[i][t]) ? actionTable[i][t] : "";
                tbody += `<td>${act}</td>`;
            });

            // Goto Columns
            nonTerminals.forEach(nt => {
                let go = (gotoTable[i] && gotoTable[i][nt] !== undefined) ? gotoTable[i][nt] : "";
                tbody += `<td>${go}</td>`;
            });
            tbody += "</tr>";
        }
        tbody += "</tbody>";
        tbl.innerHTML += tbody;
    }

    // --- Parser Engine ---

    function parseString() {
        const inputRaw = document.getElementById('testString').value.trim();
        const input = inputRaw + "$";
        const stateStack = [0]; 
        const symbolStack = ['$']; 

        let ptr = 0;
        
        const tbody = document.querySelector('#traceTable tbody');
        tbody.innerHTML = "";
        const msgDiv = document.getElementById('parseResultMsg');
        msgDiv.style.display = 'none';

        let stepLimit = 1000; 
        let steps = 0;

        while(steps < stepLimit) {
            let state = stateStack[stateStack.length-1];
            let char = input[ptr];
            
            // Find action
            let action = "";
            
            let symbol = char;
            if(!terminals.includes(symbol)) {
                alert(`Unknown symbol: ${symbol}`);
                return;
            }

            if(actionTable[state] && actionTable[state][symbol]) {
                action = actionTable[state][symbol];
            }

            // Generate interleaved stack string
            let stackDisplay = "";
            for(let i=0; i<stateStack.length; i++) {
                stackDisplay += symbolStack[i] + stateStack[i];
            }

            // Log Row
            let row = `<tr>
                <td>${stackDisplay}</td>
                <td>${input.substring(ptr)}</td>
                <td>${action || "Error"}</td>
            </tr>`;
            tbody.innerHTML += row;

            if(!action) {
                msgDiv.innerHTML = "❌ Error: Syntax Error";
                msgDiv.style.color = "red";
                msgDiv.style.display = "block";
                break;
            }

            if(action === 'acc') {
                msgDiv.innerHTML = "✅ Success: String Accepted!";
                msgDiv.style.color = "green";
                msgDiv.style.display = "block";
                break;
            }
            else if(action.startsWith('S')) {
                let nextState = parseInt(action.substring(1));
                stateStack.push(nextState);
                symbolStack.push(char); // Push the symbol
                ptr++;
            }
            else if(action.startsWith('r')) {
                let prodIdx = parseInt(action.substring(1));
                let p = grammar[prodIdx];
                
                let len = p.rhs.length;
                if(p.rhs === 'e') len = 0;

                for(let k=0; k<len; k++) {
                    stateStack.pop();
                    symbolStack.pop();
                }

                let topState = stateStack[stateStack.length-1];
                if(gotoTable[topState] && gotoTable[topState][p.lhs] !== undefined) {
                    stateStack.push(gotoTable[topState][p.lhs]);
                    symbolStack.push(p.lhs); // Push Non-Terminal
                } else {
                    break;
                }
            }
            steps++;
        }
    }
</script>

</body>
</html>