<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LL(1) Parser</title>
    <link rel="icon" type="image/png" href="../logos/LL1.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #fefce8; /* Yellow-50 */
            background-image: radial-gradient(#fbbf24 2px, transparent 2px);
            background-size: 24px 24px;
        }
        .toy-card {
            background: white;
            border: 4px solid #1e293b;
            box-shadow: 8px 8px 0px 0px #1e293b;
            border-radius: 1.5rem;
            transition: transform 0.2s;
        }
        .toy-card:hover {
            transform: translateY(-2px);
        }
        .toy-input {
            border: 3px solid #cbd5e1;
            border-radius: 1rem;
            padding: 0.75rem;
            width: 100%;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s;
        }
        .toy-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 4px #dbeafe;
        }
        .toy-btn {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: 3px solid #1e293b;
            box-shadow: 4px 4px 0px 0px #1e293b;
            transition: all 0.1s;
        }
        .toy-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px 0px #1e293b;
        }
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 6px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 6px;
            border: 3px solid #f1f5f9;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <!-- Back Button -->
    <div class="max-w-6xl mx-auto mb-4">
        <a href="../index.html" class="toy-btn inline-flex items-center gap-2 px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-800 rounded-xl">
            ‚Üê Back
        </a>
    </div>

    <!-- Header -->
    <div class="max-w-6xl mx-auto mb-8 text-center">
        <h1 class="text-4xl md:text-6xl font-black text-slate-800 mb-2 drop-shadow-sm">
            <span class="text-pink-500">LL(1)</span> Parser
        </h1>
        <p class="text-slate-600 font-semibold text-lg">Build grammars, squash recursion, and parse strings!</p>
    </div>

    <div class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-8">
        
        <!-- Left Column: Inputs -->
        <div class="lg:col-span-4 space-y-6">
            <!-- Grammar Input -->
            <div class="toy-card p-6 bg-white">
                <div class="flex items-center gap-2 mb-4">
                    <div class="w-8 h-8 bg-yellow-400 rounded-full border-2 border-black flex items-center justify-center text-black font-bold">1</div>
                    <h2 class="text-2xl font-bold text-slate-800">Grammar</h2>
                </div>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-bold text-slate-500 mb-1">Productions</label>
                        <textarea id="grammarInput" rows="6" class="toy-input" placeholder="S->aT&#10;T->A/B&#10;A->b&#10;B->c">S->aT
T->A/B
A->b
B->c</textarea>
                        <p class="text-xs text-slate-400 mt-1">Use 'e' for epsilon. Use '/' or '|' for OR. Enter Post-Recursion Productions.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-bold text-slate-500 mb-1">Non-Terminals</label>
                        <input type="text" id="nonTerminalsInput" class="toy-input" value="S,T,A,B" placeholder="S,T,A,B">
                        <p class="text-xs text-slate-400 mt-1">Use T or something instead of B'.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-bold text-slate-500 mb-1">Terminals</label>
                        <input type="text" id="terminalsInput" class="toy-input" value="a,b,c" placeholder="a,b,c">
                    </div>
                    <button onclick="processGrammar()" class="toy-btn w-full py-3 bg-blue-400 hover:bg-blue-300 text-white rounded-xl">
                        üöÄ Build Parser
                    </button>
                </div>
            </div>

            <!-- Test String Input -->
            <div class="toy-card p-6 bg-pink-50">
                <div class="flex items-center gap-2 mb-4">
                    <div class="w-8 h-8 bg-pink-400 rounded-full border-2 border-black flex items-center justify-center text-white font-bold">2</div>
                    <h2 class="text-2xl font-bold text-slate-800">Test String</h2>
                </div>
                <div class="space-y-4">
                    <input type="text" id="testString" class="toy-input bg-white" placeholder="e.g., ab">
                    <button onclick="parseString()" class="toy-btn w-full py-3 bg-green-500 hover:bg-green-400 text-white rounded-xl">
                        ‚ñ∂Ô∏è Parse String
                    </button>
                </div>
            </div>
        </div>

        <!-- Right Column: Results -->
        <div class="lg:col-span-8 space-y-6">
            
            <!-- Analysis Results (Recursion, First, Follow) -->
            <div id="analysisSection" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- Modified Grammar -->
                    <div class="toy-card p-5 bg-white">
                        <h3 class="text-lg font-bold text-purple-600 mb-2 border-b-2 border-slate-100 pb-2">üìù Modified Grammar</h3>
                        <pre id="modGrammarOutput" class="font-mono text-sm text-slate-600 whitespace-pre-wrap bg-slate-50 p-2 rounded-lg"></pre>
                    </div>
                    <!-- Sets -->
                    <div class="toy-card p-5 bg-white">
                        <h3 class="text-lg font-bold text-orange-500 mb-2 border-b-2 border-slate-100 pb-2">üîç First & Follow</h3>
                        <div id="setsOutput" class="font-mono text-sm text-slate-600 space-y-1 max-h-40 overflow-y-auto"></div>
                    </div>
                </div>

                <!-- Parsing Table -->
                <div class="toy-card p-5 bg-white overflow-x-auto mb-6">
                    <h3 class="text-lg font-bold text-teal-600 mb-4">üìä Parsing Table</h3>
                    <table class="w-full border-collapse min-w-[400px]">
                        <thead id="tableHead" class="bg-slate-100 text-slate-700"></thead>
                        <tbody id="tableBody" class="text-slate-600 font-mono"></tbody>
                    </table>
                </div>
            </div>

            <!-- Parsing Trace -->
            <div id="traceSection" class="hidden toy-card p-6 bg-white">
                <h3 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
                    <span>üì∫</span> Parsing Simulation
                </h3>
                <div class="overflow-x-auto rounded-xl border-2 border-slate-200">
                    <table class="w-full text-left border-collapse">
                        <thead class="bg-slate-800 text-white">
                            <tr>
                                <th class="p-3 w-1/3">Stack</th>
                                <th class="p-3 w-1/3">Input</th>
                                <th class="p-3 w-1/3">Action</th>
                            </tr>
                        </thead>
                        <tbody id="traceBody" class="font-mono text-sm">
                            <!-- Rows added via JS -->
                        </tbody>
                    </table>
                </div>
                <div id="parseResult" class="mt-4 text-center font-bold text-xl"></div>
            </div>

        </div>
    </div>

    <script>
        // --- Global State ---
        let productions = [];
        let nonTerminals = [];
        let terminals = [];
        let firstSets = {};
        let followSets = {};
        let parseTable = {};
        let startSymbol = '';

        // --- Helper Functions ---
        const isNonTerminal = (c) => nonTerminals.includes(c);
        const isTerminal = (c) => terminals.includes(c) || c === '$';
        
        function addToSet(set, val) {
            if (!set.includes(val)) set.push(val);
        }

        // --- 1. Parse Input & Eliminate Recursion ---
        function processGrammar() {
            // Reset state
            productions = [];
            firstSets = {};
            followSets = {};
            parseTable = {};

            // Get Inputs
            const rawGrammar = document.getElementById('grammarInput').value.trim();
            const ntInput = document.getElementById('nonTerminalsInput').value;
            const tInput = document.getElementById('terminalsInput').value;

            nonTerminals = ntInput.split(',').map(s => s.trim()).filter(s => s);
            terminals = tInput.split(',').map(s => s.trim()).filter(s => s);
            if (!terminals.includes('$')) terminals.push('$');

            // Parse Productions
            const lines = rawGrammar.split('\n');
            lines.forEach(line => {
                if(!line.trim()) return;
                const parts = line.split('->');
                if(parts.length !== 2) return;
                
                const lhs = parts[0].trim();
                const rhsParts = parts[1].split(/[\/|]/); // Split by / or |
                
                rhsParts.forEach(rhs => {
                    productions.push({ lhs: lhs, rhs: rhs.trim() });
                });
            });

            if (productions.length > 0) startSymbol = productions[0].lhs;

            eliminateLeftRecursion();
            calculateFirstSets();
            calculateFollowSets();
            buildTable();
            renderResults();
        }

        function eliminateLeftRecursion() {
            let newProds = [];
            // We need a way to add new NTs.
            // In the C code, it blindly adds 'A' + count. Here we try to be smarter or follow the same logic.
            // Let's follow the C logic: check immediate recursion.
            
            // Create a copy of NTs to iterate because we might add to it
            const currentNTs = [...nonTerminals];
            
            currentNTs.forEach(nt => {
                const ntProds = productions.filter(p => p.lhs === nt);
                const recursive = ntProds.some(p => p.rhs.startsWith(nt));

                if (recursive) {
                    // Generate Prime NT (e.g., A -> A' or Z)
                    // Simple heuristic: append '`' (prime) for display, but strict char for logic?
                    // The C code used single chars. Let's use a visually distinct char not in NT.
                    // For simplicity in this logic, let's append "'" and treat it as a single unit.
                    const primeNT = nt + "'";
                    if (!nonTerminals.includes(primeNT)) nonTerminals.push(primeNT);

                    let alphaProds = [];
                    let betaProds = [];

                    ntProds.forEach(p => {
                        if (p.rhs.startsWith(nt)) {
                            // Recursive: A -> A alpha
                            alphaProds.push(p.rhs.substring(nt.length));
                        } else {
                            // Non-recursive: A -> beta
                            betaProds.push(p.rhs);
                        }
                    });

                    // 1. A -> beta A'
                    if (betaProds.length === 0) {
                        // Only recursive rules exist? (Rare in valid grammar, implies A->Aa only)
                        // We won't handle this edge case strictly, assuming valid grammar input
                    } else {
                        betaProds.forEach(beta => {
                            newProds.push({ lhs: nt, rhs: beta + primeNT });
                        });
                    }

                    // 2. A' -> alpha A' | e
                    alphaProds.forEach(alpha => {
                        newProds.push({ lhs: primeNT, rhs: alpha + primeNT });
                    });
                    newProds.push({ lhs: primeNT, rhs: 'e' });

                } else {
                    // No recursion, keep rules
                    ntProds.forEach(p => newProds.push(p));
                }
            });

            // Keep productions for NTs we haven't processed yet (if any logic skipped)
            // Actually simpler: rebuild the whole production list.
            // The above loop processes NTs. What if an NT is not in the loop?
            // The loop covers original NTs. 
            // We replace 'productions' with 'newProds'.
            productions = newProds;
        }

        // --- 2. Sets Calculation ---

        function calculateFirstSets() {
            // Initialize
            nonTerminals.forEach(nt => firstSets[nt] = []);
            
            let changed = true;
            while(changed) {
                changed = false;
                productions.forEach(prod => {
                    const lhs = prod.lhs;
                    const rhs = prod.rhs;
                    
                    // Logic to compute First(rhs)
                    // Because tokens can be multi-char (like A'), we need a tokenizer or careful parsing.
                    // Our tokenizer: greedy match against NTs (longest first) or terminal chars.
                    // Since user input is simple chars usually, but we introduced A', we need to match carefully.
                    
                    const tokens = tokenize(rhs);
                    
                    let continueNext = true;
                    let k = 0;

                    while(continueNext && k < tokens.length) {
                        continueNext = false;
                        const sym = tokens[k];

                        if (isTerminal(sym) || sym === 'e') {
                            if (!firstSets[lhs].includes(sym)) {
                                firstSets[lhs].push(sym);
                                changed = true;
                            }
                        } else if (isNonTerminal(sym)) {
                            const symFirst = firstSets[sym] || [];
                            let hasEpsilon = false;
                            
                            symFirst.forEach(f => {
                                if (f === 'e') hasEpsilon = true;
                                else {
                                    if (!firstSets[lhs].includes(f)) {
                                        firstSets[lhs].push(f);
                                        changed = true;
                                    }
                                }
                            });
                            
                            if (hasEpsilon) continueNext = true;
                        }
                        k++;
                    }

                    if (continueNext) {
                        // If we exhausted RHS and all had epsilon
                        if (!firstSets[lhs].includes('e')) {
                            firstSets[lhs].push('e');
                            changed = true;
                        }
                    }
                });
            }
        }

        function calculateFollowSets() {
            nonTerminals.forEach(nt => followSets[nt] = []);
            if(nonTerminals.length > 0) followSets[startSymbol].push('$');

            let changed = true;
            while(changed) {
                changed = false;
                productions.forEach(prod => {
                    const lhs = prod.lhs;
                    const rhs = prod.rhs;
                    const tokens = tokenize(rhs);

                    for(let i=0; i<tokens.length; i++) {
                        const sym = tokens[i];
                        if(isNonTerminal(sym)) {
                            // Calculate First(beta) where beta is tokens[i+1...]
                            let remainderFirst = [];
                            let allEpsilon = true;
                            let k = i + 1;

                            while(k < tokens.length) {
                                const nextSym = tokens[k];
                                let nextHasEpsilon = false;

                                if(isTerminal(nextSym)) {
                                    addToSet(remainderFirst, nextSym);
                                    allEpsilon = false;
                                    break; 
                                } else if (isNonTerminal(nextSym)) {
                                    const fs = firstSets[nextSym] || [];
                                    fs.forEach(f => {
                                        if(f === 'e') nextHasEpsilon = true;
                                        else addToSet(remainderFirst, f);
                                    });
                                    if(!nextHasEpsilon) {
                                        allEpsilon = false;
                                        break;
                                    }
                                }
                                k++;
                            }

                            // Add First(beta) to Follow(sym)
                            remainderFirst.forEach(f => {
                                if(!followSets[sym].includes(f)) {
                                    followSets[sym].push(f);
                                    changed = true;
                                }
                            });

                            // If beta is epsilon (or empty), add Follow(LHS) to Follow(sym)
                            if(allEpsilon) {
                                const lhsFollow = followSets[lhs] || [];
                                lhsFollow.forEach(f => {
                                    if(!followSets[sym].includes(f)) {
                                        followSets[sym].push(f);
                                        changed = true;
                                    }
                                });
                            }
                        }
                    }
                });
            }
        }

        // --- 3. Build Table ---
        function buildTable() {
            nonTerminals.forEach(nt => {
                parseTable[nt] = {};
                terminals.forEach(t => parseTable[nt][t] = -1); // -1 or null
            });

            productions.forEach((prod, index) => {
                const lhs = prod.lhs;
                const rhs = prod.rhs;
                const tokens = tokenize(rhs);

                // Calc First(RHS)
                let firstRHS = [];
                let hasEpsilon = true;

                for(let sym of tokens) {
                    hasEpsilon = false;
                    if(isTerminal(sym) || sym === 'e') {
                        if(sym !== 'e') addToSet(firstRHS, sym);
                        else hasEpsilon = true;
                        break; // Terminal stops first set propagation
                    } else if (isNonTerminal(sym)) {
                        const fs = firstSets[sym] || [];
                        let symHasEpsilon = false;
                        fs.forEach(f => {
                            if(f === 'e') symHasEpsilon = true;
                            else addToSet(firstRHS, f);
                        });
                        if(!symHasEpsilon) break;
                        hasEpsilon = true; // Continue to next symbol if this one has epsilon
                    }
                }
                if(tokens.length === 1 && tokens[0] === 'e') hasEpsilon = true;

                // Rule 1: Add A->alpha to M[A, a] for a in First(alpha)
                firstRHS.forEach(t => {
                    parseTable[lhs][t] = index;
                });

                // Rule 2: If e in First(alpha), add A->alpha to M[A, b] for b in Follow(A)
                if(hasEpsilon) {
                    const follow = followSets[lhs] || [];
                    follow.forEach(t => {
                        parseTable[lhs][t] = index;
                    });
                }
            });
        }

        // --- Tokenizer Utility ---
        // Splits "AbA'" into ["A", "b", "A'"]
        function tokenize(str) {
            // Sort non-terminals by length desc to match longest first (e.g., A' before A)
            const sortedNTs = [...nonTerminals].sort((a,b) => b.length - a.length);
            let tokens = [];
            let remaining = str;

            if (remaining === 'e') return ['e'];

            while(remaining.length > 0) {
                let matched = false;
                // Try matching a NT
                for(let nt of sortedNTs) {
                    if(remaining.startsWith(nt)) {
                        tokens.push(nt);
                        remaining = remaining.substring(nt.length);
                        matched = true;
                        break;
                    }
                }
                if(!matched) {
                    // Assume single char terminal
                    tokens.push(remaining[0]);
                    remaining = remaining.substring(1);
                }
            }
            return tokens;
        }

        // --- 4. Rendering ---

        function renderResults() {
            document.getElementById('analysisSection').classList.remove('hidden');
            
            // Render Modified Grammar
            const grammarHTML = productions.map(p => `${p.lhs} -> ${p.rhs}`).join('\n');
            document.getElementById('modGrammarOutput').textContent = grammarHTML;

            // Render Sets
            let setsHTML = '';
            nonTerminals.forEach(nt => {
                const f = firstSets[nt] ? `{ ${firstSets[nt].join(', ')} }` : '{}';
                const fl = followSets[nt] ? `{ ${followSets[nt].join(', ')} }` : '{}';
                setsHTML += `<div class="grid grid-cols-12 gap-2"><div class="col-span-2 font-bold text-blue-600">${nt}</div><div class="col-span-5 text-xs md:text-sm">FIRST: ${f}</div><div class="col-span-5 text-xs md:text-sm">FOLLOW: ${fl}</div></div>`;
            });
            document.getElementById('setsOutput').innerHTML = setsHTML;

            // Render Table
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');
            
            // Header
            let headerRow = '<tr><th class="p-2 border bg-slate-200">NT</th>';
            terminals.forEach(t => headerRow += `<th class="p-2 border text-center text-pink-600">${t}</th>`);
            headerRow += '</tr>';
            thead.innerHTML = headerRow;

            // Body
            let bodyRows = '';
            nonTerminals.forEach(nt => {
                let row = `<tr><td class="p-2 border font-bold text-blue-600 bg-slate-50">${nt}</td>`;
                terminals.forEach(t => {
                    const prodIdx = parseTable[nt][t];
                    let cellContent = '';
                    if(prodIdx !== -1 && prodIdx !== undefined) {
                        const p = productions[prodIdx];
                        cellContent = `${p.lhs}‚Üí${p.rhs}`;
                    }
                    row += `<td class="p-2 border text-center text-xs hover:bg-yellow-100 transition-colors cursor-default">${cellContent}</td>`;
                });
                row += '</tr>';
                bodyRows += row;
            });
            tbody.innerHTML = bodyRows;
        }

        // --- 5. Parser Engine ---
        
        function parseString() {
            document.getElementById('traceSection').classList.remove('hidden');
            const resultDiv = document.getElementById('parseResult');
            const tbody = document.getElementById('traceBody');
            tbody.innerHTML = '';
            resultDiv.className = "mt-4 text-center font-bold text-xl";
            resultDiv.textContent = "";

            let inputStr = document.getElementById('testString').value.trim();
            if(!inputStr.endsWith('$')) inputStr += '$';

            let stack = ['$', startSymbol];
            let ptr = 0;
            let stepCount = 0;
            const maxSteps = 100; // Prevent infinite loop

            while(stepCount < maxSteps) {
                const top = stack[stack.length-1];
                const currentInput = inputStr[ptr];
                
                // Visualization Row
                const row = document.createElement('tr');
                row.className = "border-b border-slate-200 hover:bg-slate-50";
                // Use join('') for stack to show string, space separated for clarity
                row.innerHTML = `
                    <td class="p-2 text-blue-600 font-bold">${stack.join('')}</td>
                    <td class="p-2 text-pink-600 font-bold">${inputStr.substring(ptr)}</td>
                    <td class="p-2 text-slate-500" id="action-${stepCount}"></td>
                `;
                tbody.appendChild(row);

                const actionCell = document.getElementById(`action-${stepCount}`);

                // Success Check
                if(top === '$' && currentInput === '$') {
                    actionCell.textContent = "ACCEPTED";
                    actionCell.className = "p-2 text-green-600 font-bold";
                    resultDiv.textContent = "üéâ String Accepted!";
                    resultDiv.classList.add("text-green-600");
                    return;
                }

                if(isTerminal(top) || top === '$') {
                    if(top === currentInput) {
                        actionCell.textContent = `Match '${currentInput}'`;
                        stack.pop();
                        ptr++;
                    } else {
                        actionCell.textContent = "Error: Mismatch";
                        actionCell.className = "p-2 text-red-500 font-bold";
                        resultDiv.textContent = "‚ùå Error: Terminal Mismatch";
                        resultDiv.classList.add("text-red-500");
                        return;
                    }
                } else {
                    // Non-Terminal
                    // Find production M[top, currentInput]
                    // Need to handle if currentInput is not in terminals (invalid char)
                    if(!terminals.includes(currentInput)) {
                        actionCell.textContent = "Error: Unknown Symbol";
                        resultDiv.textContent = "‚ùå Error: Unknown Symbol in Input";
                        resultDiv.classList.add("text-red-500");
                        return;
                    }

                    const prodIdx = parseTable[top][currentInput];
                    if(prodIdx !== -1 && prodIdx !== undefined) {
                        const prod = productions[prodIdx];
                        actionCell.textContent = `Output ${prod.lhs} -> ${prod.rhs}`;
                        stack.pop();
                        // Push RHS reversed
                        if(prod.rhs !== 'e') {
                            // Must tokenize RHS to push correctly (handle A' etc)
                            const rhsTokens = tokenize(prod.rhs);
                            for(let i=rhsTokens.length-1; i>=0; i--) {
                                stack.push(rhsTokens[i]);
                            }
                        }
                    } else {
                        actionCell.textContent = "Error: No Rule";
                        actionCell.className = "p-2 text-red-500 font-bold";
                        resultDiv.textContent = "‚ùå Error: Parsing Table Empty";
                        resultDiv.classList.add("text-red-500");
                        return;
                    }
                }
                stepCount++;
            }
            if(stepCount >= maxSteps) {
                resultDiv.textContent = "‚ö†Ô∏è Stopped: Loop limit reached";
                resultDiv.classList.add("text-orange-500");
            }
        }

    </script>
</body>
</html>