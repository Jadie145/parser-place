<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LALR Parser - Auto Run</title>
    <link rel="icon" type="image/png" href="../logos/LALR.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
    <style>
        :root {
            --c-bg: #fdf6e3;
            --c-primary: #ff90e8; /* Pink */
            --c-secondary: #51e2f5; /* Cyan */
            --c-accent: #ffbd03; /* Yellow */
            --c-purple: #bd93f9;
            --c-dark: #232323;
            --c-light: #ffffff;
            --font-main: 'Courier New', Courier, monospace;
            --font-head: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            --shadow-hard: 6px 6px 0px var(--c-dark);
            --shadow-hover: 2px 2px 0px var(--c-dark);
        }

        * { box-sizing: border-box; }

        body {
            font-family: var(--font-main);
            background-color: var(--c-bg);
            background-image: radial-gradient(var(--c-dark) 1px, transparent 1px);
            background-size: 24px 24px;
            color: var(--c-dark);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* --- Back Button --- */
        .back-btn {
            display: inline-block;
            background: var(--c-light);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 12px 24px;
            text-decoration: none;
            color: var(--c-dark);
            font-weight: bold;
            font-family: var(--font-head);
            text-transform: uppercase;
            margin-bottom: 20px;
            transition: all 0.15s;
        }

        .back-btn:hover {
            background: var(--c-secondary);
            box-shadow: var(--shadow-hover);
            transform: translate(4px, 4px);
        }

        /* --- Header --- */
        header {
            background: var(--c-accent);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 30px;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            width: 100%;
            height: 100%;
            border: 4px solid var(--c-dark);
            z-index: -1;
            background: var(--c-primary);
        }

        h1 {
            font-family: var(--font-head);
            margin: 0;
            text-transform: uppercase;
            font-weight: 900;
            font-size: 2.8rem;
            letter-spacing: -2px;
            color: var(--c-dark);
            text-shadow: 3px 3px 0px #fff;
        }

        h2, h3 {
            font-family: var(--font-head);
            text-transform: uppercase;
            margin-top: 0;
        }

        /* --- Cards --- */
        .card {
            background: var(--c-light);
            border: 4px solid var(--c-dark);
            box-shadow: var(--shadow-hard);
            padding: 30px;
            margin-bottom: 40px;
            position: relative;
            transition: transform 0.2s;
        }

        .card-badge {
            background: var(--c-dark);
            color: var(--c-light);
            padding: 8px 20px;
            font-weight: bold;
            position: absolute;
            top: -20px;
            left: 20px;
            transform: rotate(-2deg);
            border: 2px solid var(--c-light);
            font-family: var(--font-head);
            z-index: 10;
        }

        /* --- Form Elements --- */
        .input-group { margin-bottom: 20px; }

        label {
            display: block;
            font-weight: 800;
            margin-bottom: 8px;
            font-family: var(--font-head);
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        textarea, input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 3px solid var(--c-dark);
            background: #f8f8f8;
            font-family: var(--font-main);
            font-size: 1rem;
            outline: none;
            transition: 0.2s;
        }

        textarea:focus, input[type="text"]:focus {
            background: #fff;
            border-color: var(--c-primary);
            box-shadow: 4px 4px 0px var(--c-primary);
        }

        button {
            background: var(--c-secondary);
            color: var(--c-dark);
            border: 3px solid var(--c-dark);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 900;
            font-family: var(--font-head);
            cursor: pointer;
            box-shadow: var(--shadow-hard);
            text-transform: uppercase;
            display: block;
            width: 100%;
            transition: all 0.1s;
        }

        button:hover {
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0px var(--c-dark);
            background: #8df0fa;
        }

        button:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px var(--c-dark);
        }

        /* --- Output Areas --- */
        .result-section { display: none; animation: fadeIn 0.5s; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .output-block {
            background: #f0f0f0;
            border: 2px solid var(--c-dark);
            padding: 15px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        /* --- Tables --- */
        .table-wrapper {
            overflow-x: auto;
            border: 3px solid var(--c-dark);
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            min-width: 600px;
        }

        th, td {
            border: 1px solid var(--c-dark);
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
        }

        th {
            background: var(--c-primary);
            color: var(--c-dark);
            font-weight: 900;
        }

        tr:nth-child(even) { background: #fcf0e4; }
        
        .conflict { background: #ff6b6b !important; color: white; font-weight: bold; }
        .merged-highlight { background: #e3dfff !important; }

        /* --- Grid and Flex --- */
        .states-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .state-box {
            background: #fff;
            border: 3px solid var(--c-dark);
            padding: 0;
            box-shadow: 4px 4px 0px #ddd;
        }

        .state-header {
            background: var(--c-dark);
            color: var(--c-secondary);
            padding: 8px;
            font-weight: bold;
            border-bottom: 3px solid var(--c-dark);
            display: flex;
            justify-content: space-between;
        }

        .state-body { padding: 10px; font-size: 0.85rem; }
        .state-item { margin-bottom: 4px; border-bottom: 1px dashed #ccc; padding-bottom: 2px; }

        /* --- Graph --- */
        #graphDiv {
            background: white;
            padding: 10px;
            text-align: center;
            overflow-x: auto;
        }
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    
    <header>
        <h1>LALR Parser Generator</h1>
        <div style="margin-top: 10px; font-weight: bold;">LR(1) to LALR Conversion & Simulation</div>
    </header>

    <!-- Input Section -->
    <div class="card">
        <div class="card-badge">INPUT CONFIG</div>
        
        <div class="input-group">
            <label>Grammar Productions</label>
            <textarea id="inputGrammar" rows="5" placeholder="S->CC...">S->CC
C->cC|d</textarea>
            <small style="display:block; margin-top:5px; color:#666;">
                Format: LHS->RHS (use '|' or '/' for OR, 'e' for epsilon).
            </small>
        </div>

        <div class="input-group">
            <label>Terminals (Space Separated)</label>
            <input type="text" id="inputTerminals" value="c d" placeholder="i ( )">
        </div>

        <div class="input-group">
            <label>Non-Terminals (Space Separated)</label>
            <input type="text" id="inputNonTerminals" value="S C" placeholder="E">
        </div>

        <button onclick="runParser()">RE-GENERATE PARSER</button>
    </div>

    <!-- Results Section -->
    <div id="resultsArea" class="result-section">
        
        <!-- 1. Grammar Info -->
        <div class="card" style="border-color: var(--c-primary);">
            <div class="card-badge" style="background: var(--c-primary); color:black;">1. ANALYSIS</div>
            <div style="display: flex; flex-wrap: wrap; gap: 20px;">
                <div style="flex: 1;">
                    <h3>Augmented Grammar</h3>
                    <div id="augGrammarOutput" class="output-block"></div>
                </div>
                <div style="flex: 1;">
                    <h3>First Sets</h3>
                    <div id="firstSetsOutput" class="output-block"></div>
                </div>
            </div>
        </div>

        <!-- 2. LR(1) States -->
        <div class="card">
            <div class="card-badge">2. LR(1) STATES</div>
            <p>Canonical Collection of LR(1) items. <small>Format: <code>A -> &alpha; . &beta; , [lookahead]</code></small></p>
            <div id="lr1StatesOutput" class="states-grid"></div>
        </div>

        <!-- 3. LR(1) Table -->
        <div class="card">
            <div class="card-badge">3. LR(1) PRODUCTION MATRIX</div>
            <p>Original parsing table before merging.</p>
            <div class="table-wrapper">
                <table id="lr1Table"></table>
            </div>
        </div>

        <!-- 4. LALR Conversion Logic -->
        <div class="card" style="border-color: var(--c-purple);">
            <div class="card-badge" style="background: var(--c-purple); color:black;">4. COMBINATION I SETS</div>
            <p>Merging LR(1) states that share the same core items (productions & dots), ignoring lookaheads.</p>
            <div id="mergeLog" class="output-block" style="background: #fdf6e3; border-color: var(--c-purple);"></div>
            <br>
            <h3>LALR (Merged) States</h3>
            <div id="lalrStatesOutput" class="states-grid"></div>
        </div>

        <!-- 5. LALR Table -->
        <div class="card">
            <div class="card-badge" style="background: var(--c-secondary); color:black;">5. LALR PRODUCTION MATRIX</div>
            <p>The final reduced table used for parsing.</p>
            <div class="table-wrapper">
                <table id="lalrTable"></table>
            </div>
        </div>

        <!-- 6. Graph -->
        <div class="card" style="border-color: var(--c-secondary);">
            <div class="card-badge" style="background: var(--c-secondary); color:black;">6. LALR GRAPH</div>
            <div id="graphDiv">Graph will appear here...</div>
        </div>

        <!-- 7. Simulator -->
        <div class="card" style="background: #fff4f4; border-color: var(--c-accent);">
            <div class="card-badge" style="background: var(--c-accent); color:black;">7. SIMULATOR</div>
            <div class="input-group">
                <label>Test String (without $)</label>
                <input type="text" id="testString" placeholder="cdd" value="cdd">
            </div>
            <button onclick="parseString()" style="background: var(--c-primary);">PARSE STRING (USING LALR TABLE)</button>
            
            <div id="parseResultMsg" style="margin: 15px 0; font-weight: bold; font-size: 1.2rem; text-align: center;"></div>

            <div class="table-wrapper">
                <table id="traceTable">
                    <thead>
                        <tr>
                            <th style="width: 40%">Stack</th>
                            <th style="width: 30%">Input</th>
                            <th style="width: 30%">Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>
</div>

<script>
    // Initialize Mermaid
    mermaid.initialize({ startOnLoad: false, theme: 'neutral', securityLevel: 'loose' });

    // --- Data Structures ---
    class Production {
        constructor(id, lhs, rhs) {
            this.id = id;
            this.lhs = lhs;
            this.rhs = rhs; 
        }
    }

    class Item {
        constructor(prodIndex, dotPos, lookahead) {
            this.prodIndex = prodIndex;
            this.dotPos = dotPos;
            this.lookahead = lookahead; 
        }
        
        // Full key for LR(1) equality
        getKey() {
            return `${this.prodIndex}:${this.dotPos}:${this.lookahead}`;
        }

        // Core key for LALR merging (ignores lookahead)
        getCoreKey() {
            return `${this.prodIndex}:${this.dotPos}`;
        }
    }

    // --- Global State ---
    let grammar = [];
    let terminals = [];
    let nonTerminals = [];
    let firstSets = {};
    
    // LR(1) specific
    let lr1States = []; 
    let lr1ActionTable = {};
    let lr1GotoTable = {};
    let lr1GotoGraph = [];

    // LALR specific
    let lalrStates = [];
    let lalrActionTable = {};
    let lalrGotoTable = {};
    let lalrGotoGraph = [];
    let lr1ToLalrMap = {}; // Maps LR1 index -> LALR index

    // --- Main Execution ---
    function runParser() {
        resetData();
        
        if(!parseInput()) return;

        // 1. Analysis
        computeFirstSets();
        displayGrammarInfo();

        // 2. Build LR(1)
        generateLR1Collection();
        buildLR1Tables();
        
        // 3. Convert to LALR
        convertToLALR();

        // 4. Render All
        renderLR1States();
        renderTable(lr1States, lr1ActionTable, lr1GotoTable, 'lr1Table');
        renderLALRInfo();
        renderTable(lalrStates, lalrActionTable, lalrGotoTable, 'lalrTable');
        renderLALRGraph();

        document.getElementById('resultsArea').style.display = 'block';
    }

    function resetData() {
        grammar = [];
        lr1States = []; lr1GotoGraph = []; lr1ActionTable = {}; lr1GotoTable = {};
        lalrStates = []; lalrGotoGraph = []; lalrActionTable = {}; lalrGotoTable = {};
        firstSets = {}; lr1ToLalrMap = {};
    }

    function parseInput() {
        const gText = document.getElementById('inputGrammar').value.trim();
        const tText = document.getElementById('inputTerminals').value.trim();
        const ntText = document.getElementById('inputNonTerminals').value.trim();

        if(!gText || !tText || !ntText) { alert("Please fill all fields"); return false; }

        terminals = tText.split(/\s+/);
        if(!terminals.includes('$')) terminals.push('$');
        
        nonTerminals = ntText.split(/\s+/);
        if(!nonTerminals.includes('Z')) nonTerminals.unshift('Z'); 

        let rawLines = gText.split('\n');
        let prodCount = 0;
        
        let userStart = nonTerminals[1]; 
        grammar.push(new Production(0, 'Z', userStart));
        prodCount++;

        rawLines.forEach(line => {
            if(!line.trim()) return;
            let parts = line.split(/->|=/);
            if(parts.length < 2) return;
            let lhs = parts[0].trim();
            let rhsList = parts[1].split(/\/|\|/);
            
            rhsList.forEach(rhs => {
                grammar.push(new Production(prodCount++, lhs, rhs.trim()));
            });
        });
        return true;
    }

    function displayGrammarInfo() {
        let augHtml = grammar.map(p => `${p.id}: ${p.lhs} -> ${p.rhs}`).join('\n');
        document.getElementById('augGrammarOutput').innerText = augHtml;

        let firstHtml = Object.keys(firstSets).map(k => `FIRST(${k}) = { ${Array.from(firstSets[k]).join(', ')} }`).join('\n');
        document.getElementById('firstSetsOutput').innerText = firstHtml;
    }

    // --- Logic: First Sets ---
    function computeFirstSets() {
        nonTerminals.forEach(nt => firstSets[nt] = new Set());
        terminals.forEach(t => firstSets[t] = new Set([t]));
        
        let changed = true;
        while(changed) {
            changed = false;
            grammar.forEach(prod => {
                let lhs = prod.lhs;
                let rhs = prod.rhs;
                let initialSize = firstSets[lhs].size;

                if(rhs === 'e') {
                    firstSets[lhs].add('e');
                } else {
                    let rhsFirst = getFirstOfString(rhs);
                    rhsFirst.forEach(x => firstSets[lhs].add(x));
                }
                if(firstSets[lhs].size > initialSize) changed = true;
            });
        }
    }

    function getFirstOfString(str) {
        let result = new Set();
        let allNullable = true;
        for(let i=0; i<str.length; i++) {
            let sym = str[i];
            let symFirst = firstSets[sym];
            if(!symFirst) { result.add(sym); allNullable = false; break; }
            
            let hasEpsilon = false;
            symFirst.forEach(x => {
                if(x === 'e') hasEpsilon = true;
                else result.add(x);
            });
            if(!hasEpsilon) { allNullable = false; break; }
        }
        if(allNullable) result.add('e');
        return result;
    }

    // --- Logic: LR(1) Generation ---
    function closure(items) {
        let currentItems = [...items];
        let added = true;
        while(added) {
            added = false;
            for(let i=0; i<currentItems.length; i++) {
                let item = currentItems[i];
                let prod = grammar[item.prodIndex];
                let rhs = prod.rhs;

                if(item.dotPos < rhs.length && rhs !== 'e') {
                    let B = rhs[item.dotPos];
                    if(nonTerminals.includes(B)) {
                        let beta = rhs.substring(item.dotPos + 1);
                        let firstOfBetaA = getFirstOfString(beta + item.lookahead);
                        
                        grammar.forEach((p, pIdx) => {
                            if(p.lhs === B) {
                                firstOfBetaA.forEach(b => {
                                    if(b === 'e') return; 
                                    let newItem = new Item(pIdx, 0, b);
                                    if(!currentItems.some(ex => ex.getKey() === newItem.getKey())) {
                                        currentItems.push(newItem);
                                        added = true;
                                    }
                                });
                            }
                        });
                    }
                }
            }
        }
        return currentItems.sort((a,b) => a.getKey().localeCompare(b.getKey()));
    }

    function goto(items, symbol) {
        let newItems = [];
        items.forEach(item => {
            let prod = grammar[item.prodIndex];
            let rhs = prod.rhs;
            if(rhs === 'e') return;
            if(item.dotPos < rhs.length && rhs[item.dotPos] === symbol) {
                newItems.push(new Item(item.prodIndex, item.dotPos + 1, item.lookahead));
            }
        });
        if(newItems.length === 0) return null;
        return closure(newItems);
    }

    function sameState(s1, s2) {
        if(s1.length !== s2.length) return false;
        for(let i=0; i<s1.length; i++) {
            if(s1[i].getKey() !== s2[i].getKey()) return false;
        }
        return true;
    }

    function generateLR1Collection() {
        let startItem = new Item(0, 0, '$');
        lr1States.push(closure([startItem]));

        let processed = 0;
        while(processed < lr1States.length) {
            let currentI = lr1States[processed];
            let symbolsAfterDot = new Set();
            
            currentI.forEach(item => {
                let rhs = grammar[item.prodIndex].rhs;
                if(rhs !== 'e' && item.dotPos < rhs.length) {
                    symbolsAfterDot.add(rhs[item.dotPos]);
                }
            });

            symbolsAfterDot.forEach(sym => {
                let nextI = goto(currentI, sym);
                if(nextI) {
                    let existingIdx = -1;
                    for(let k=0; k<lr1States.length; k++) {
                        if(sameState(lr1States[k], nextI)) { existingIdx = k; break; }
                    }
                    if(existingIdx === -1) {
                        existingIdx = lr1States.length;
                        lr1States.push(nextI);
                    }
                    lr1GotoGraph.push({ from: processed, to: existingIdx, label: sym });
                }
            });
            processed++;
        }
    }

    function buildLR1Tables() {
        // Standard LR(1) table construction for display
        fillTable(lr1States, lr1ActionTable, lr1GotoTable, lr1GotoGraph);
    }

    function fillTable(states, actTable, gTable, graphEdges) {
        // 1. Shifts and Gotos from Graph
        graphEdges.forEach(edge => {
            if(terminals.includes(edge.label)) {
                if(!actTable[edge.from]) actTable[edge.from] = {};
                actTable[edge.from][edge.label] = `S${edge.to}`;
            } else {
                if(!gTable[edge.from]) gTable[edge.from] = {};
                gTable[edge.from][edge.label] = edge.to;
            }
        });

        // 2. Reductions
        states.forEach((items, idx) => {
            items.forEach(item => {
                let prod = grammar[item.prodIndex];
                if((prod.rhs === 'e' && item.dotPos === 0) || item.dotPos === prod.rhs.length) {
                    if(prod.lhs === 'Z' && item.lookahead === '$') {
                        if(!actTable[idx]) actTable[idx] = {};
                        actTable[idx]['$'] = 'acc';
                    } else if (prod.lhs !== 'Z') {
                        let la = item.lookahead;
                        if(!actTable[idx]) actTable[idx] = {};
                        let existing = actTable[idx][la];
                        let reduce = `r${prod.id}`;
                        if(existing && !existing.includes(reduce)) {
                            actTable[idx][la] += `/${reduce}`; // Conflict
                        } else if (!existing) {
                            actTable[idx][la] = reduce;
                        }
                    }
                }
            });
        });
    }

    // --- Logic: LALR Conversion ---
    function convertToLALR() {
        // 1. Group LR(1) states by Core
        let coreMap = {}; // signature -> [stateIndices]

        lr1States.forEach((state, idx) => {
            // Create signature: sorted list of "ProdIndex:DotPos"
            let coreSig = state.map(item => item.getCoreKey()).sort().filter((v, i, a) => a.indexOf(v) === i).join('|');
            if(!coreMap[coreSig]) coreMap[coreSig] = [];
            coreMap[coreSig].push(idx);
        });

        // 2. Create Merged States
        let newIndex = 0;
        let logHtml = "";

        Object.values(coreMap).forEach(indices => {
            // Merging logic: Union of items + lookaheads
            let combinedItems = [];
            
            // To merge efficiently, use a map: "Prod:Dot" -> Set(Lookaheads)
            let itemMap = {}; 
            
            indices.forEach(oldIdx => {
                lr1ToLalrMap[oldIdx] = newIndex; // Record mapping
                
                lr1States[oldIdx].forEach(item => {
                    let key = item.getCoreKey();
                    if(!itemMap[key]) itemMap[key] = new Set();
                    itemMap[key].add(item.lookahead);
                });
            });

            // Reconstruct Items
            Object.keys(itemMap).forEach(key => {
                let parts = key.split(':');
                let pIdx = parseInt(parts[0]);
                let dPos = parseInt(parts[1]);
                // We create one item per lookahead to match Item structure expected by renderers
                itemMap[key].forEach(la => {
                    combinedItems.push(new Item(pIdx, dPos, la));
                });
            });
            
            lalrStates.push(combinedItems);

            // Logging
            logHtml += `<div><strong>LALR State I${newIndex}</strong> formed by merging LR(1) States: { ${indices.join(', ')} }</div>`;
            
            newIndex++;
        });

        document.getElementById('mergeLog').innerHTML = logHtml;

        // 3. Build LALR Graph (Translate LR1 edges)
        lr1GotoGraph.forEach(edge => {
            let newFrom = lr1ToLalrMap[edge.from];
            let newTo = lr1ToLalrMap[edge.to];
            
            // Avoid duplicates
            let exists = lalrGotoGraph.some(e => e.from === newFrom && e.to === newTo && e.label === edge.label);
            if(!exists) {
                lalrGotoGraph.push({ from: newFrom, to: newTo, label: edge.label });
            }
        });

        // 4. Build LALR Tables
        fillTable(lalrStates, lalrActionTable, lalrGotoTable, lalrGotoGraph);
    }


    // --- Rendering ---

    function renderLR1States() {
        renderStateGrid(lr1States, 'lr1StatesOutput');
    }

    function renderLALRInfo() {
        renderStateGrid(lalrStates, 'lalrStatesOutput');
    }

    function renderStateGrid(statesArr, containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = "";
        statesArr.forEach((items, idx) => {
            let div = document.createElement('div');
            div.className = 'state-box';
            
            // Group items by core for display cleanliness
            let displayMap = {};
            items.forEach(it => {
                let k = it.getCoreKey();
                if(!displayMap[k]) displayMap[k] = [];
                displayMap[k].push(it.lookahead);
            });

            let html = `<div class="state-header"><span>State I${idx}</span></div><div class="state-body">`;
            
            Object.keys(displayMap).forEach(k => {
                let parts = k.split(':');
                let p = grammar[parseInt(parts[0])];
                let d = parseInt(parts[1]);
                let lookaheads = displayMap[k].sort().join('/');
                
                let rhsStr = "";
                if(p.rhs === 'e') rhsStr = "."; 
                else rhsStr = p.rhs.substring(0, d) + "." + p.rhs.substring(d);
                
                html += `<div class="state-item">${p.lhs} &rarr; ${rhsStr}, <b>[${lookaheads}]</b></div>`;
            });
            html += "</div>";
            div.innerHTML = html;
            container.appendChild(div);
        });
    }

    function renderTable(states, actT, gotoT, tableId) {
        const tbl = document.getElementById(tableId);
        tbl.innerHTML = "";
        
        let head = "<thead><tr><th>State</th>";
        terminals.forEach(t => head += `<th>${t}</th>`);
        nonTerminals.forEach(nt => { if(nt !== 'Z') head += `<th>${nt}</th>`; });
        head += "</tr></thead><tbody>";

        for(let i=0; i<states.length; i++) {
            head += `<tr><td><b>${i}</b></td>`;
            terminals.forEach(t => {
                let act = (actT[i] && actT[i][t]) ? actT[i][t] : "";
                let cls = act.includes('/') ? 'conflict' : '';
                head += `<td class="${cls}">${act}</td>`;
            });
            nonTerminals.forEach(nt => {
                if(nt !== 'Z') {
                    let g = (gotoT[i] && gotoT[i][nt] !== undefined) ? gotoT[i][nt] : "";
                    head += `<td>${g}</td>`;
                }
            });
            head += "</tr>";
        }
        head += "</tbody>";
        tbl.innerHTML = head;
    }

    function renderLALRGraph() {
        let def = "graph TD;\n";
        for(let i=0; i<lalrStates.length; i++) {
            def += `S${i}(("I${i}"))\n`;
            def += `style S${i} fill:#fff,stroke:#333,stroke-width:2px\n`;
        }
        lalrGotoGraph.forEach(edge => {
            def += `S${edge.from} -- ${edge.label} --> S${edge.to}\n`;
        });

        const div = document.getElementById('graphDiv');
        div.innerHTML = `<pre class="mermaid">${def}</pre>`;
        div.removeAttribute('data-processed');
        mermaid.run({ nodes: [div.querySelector('.mermaid')] });
    }

    // --- Simulation (Uses LALR Tables) ---
    function parseString() {
        let input = document.getElementById('testString').value.trim();
        input += "$";
        let stack = [0];
        let symStack = ['$']; 
        let ptr = 0;
        
        let tbody = document.querySelector("#traceTable tbody");
        tbody.innerHTML = "";
        let msg = document.getElementById("parseResultMsg");
        msg.innerHTML = "";

        let maxSteps = 500;
        let steps = 0;

        while(steps < maxSteps) {
            let currentState = stack[stack.length - 1];
            let currentSym = input[ptr];
            
            if(!terminals.includes(currentSym)) {
                msg.innerText = `Error: Unknown symbol '${currentSym}'`;
                msg.style.color = "red"; return;
            }

            // USE LALR TABLES HERE
            let action = lalrActionTable[currentState] ? lalrActionTable[currentState][currentSym] : null;
            
            let stackDisplay = "";
            for(let i=0; i<stack.length; i++) stackDisplay += symStack[i] + stack[i];

            let row = `<tr><td style="font-family:monospace">${stackDisplay}</td><td>${input.substring(ptr)}</td><td>${action || "Error"}</td></tr>`;
            tbody.innerHTML += row;

            if(!action) {
                msg.innerText = "REJECTED: Syntax Error";
                msg.style.color = "red"; return;
            }

            if(action.includes('/')) {
                // Simple greedy conflict resolution for simulator
                let parts = action.split('/');
                let shift = parts.find(p => p.startsWith('S'));
                action = shift ? shift : parts[0];
            }

            if(action === 'acc') {
                msg.innerText = "ACCEPTED: Valid String";
                msg.style.color = "#009900"; return;
            }

            if(action.startsWith('S')) {
                let nextState = parseInt(action.substring(1));
                stack.push(nextState);
                symStack.push(currentSym);
                ptr++;
            } else if (action.startsWith('r')) {
                let prodId = parseInt(action.substring(1));
                let prod = grammar.find(p => p.id === prodId);
                let popCount = prod.rhs === 'e' ? 0 : prod.rhs.length;
                
                for(let k=0; k<popCount; k++) { stack.pop(); symStack.pop(); }
                
                let top = stack[stack.length - 1];
                // USE LALR GOTO
                let nextState = lalrGotoTable[top][prod.lhs];
                
                if(nextState === undefined) {
                    msg.innerText = "Error: Goto Fault"; msg.style.color = "red"; return;
                }
                stack.push(nextState);
                symStack.push(prod.lhs);
            }
            steps++;
        }
        msg.innerText = "Terminated: Step Limit";
    }

    // Auto-run on load
    window.onload = runParser;
</script>

</body>
</html>